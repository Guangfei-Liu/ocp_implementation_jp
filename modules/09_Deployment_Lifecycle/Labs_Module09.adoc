:toc2:

:numbered:


== Lab: Rollback/Activate and Code Lifecycle

Not every coder is perfect, and sometimes you want to rollback to a previous
incarnation of your application. Sometimes you then want to go forward to a
newer version, too.

The next few labs require that you have a Github account. We will take Marina's
"wiring" application and modify its front-end and then rebuild. We'll roll-back
to the original version, and then go forward to our re-built version.

=== Fork the Repository

. Using the git web interface, fork the following git repo:
link:https://github.com/openshift/ruby-hello-world[https://github.com/openshift/ruby-hello-world]

. Fork this into your own account by clicking the *Fork* Button at
the upper right corner of the Github web UI.

=== Create your application

NOTE: Remember that a `BuildConfig`(uration) tells OpenShift how to do a build.

. As *root*, Create a project for Marina to work with:
+
----
[root@master00 ~]# oadm new-project lifecycle --display-name="Lifecycle Lab" \
    --description="This is the project we use to learn about Lifecycle management" \
    --admin=marina --node-selector='region=primary'
----

. Switch to Marina and use the *"lifecycle"* project.
+
----
[root@master00 ~]# su - marina
[marina@master00 ~]$ oc login -u marina --insecure-skip-tls-verify --server=https://master00-${guid}.oslab.opentlc.com:8443
[marina@master00 ~]$ oc project lifecycle
----

. Lets create an app based on the link:https://github.com/openshift/ruby-hello-world[https://github.com/openshift/ruby-hello-world] repo
+
----
[marina@master00~]$ oc new-app https://github.com/openshift/ruby-hello-world --strategy=source
----
+
NOTE: Notice that we are using `"--strategy=source"` to force the *oc new-app*
command to use the S2I strategy.
NOTE: You could have, of course, started the new-app with your own repo, we are only picking the "wrong" one as part of the learning exercise.

. Since we know that we want to talk to a database eventually, let's take a moment to add the environment variables for it. Conveniently, there is an env subcommand to oc. As marina, we can use it like so:
+
----
[marina@master00~]$ oc env dc/ruby-hello-world MYSQL_USER=root \
  MYSQL_PASSWORD=redhat MYSQL_DATABASE=mydb
----

. While we wait for the build to finish, lets *expose* our service to the world so we can test this from our local browser:
+

----
[marina@master00~]$ oc expose service ruby-hello-world \
  --name="ruby-hello-world" \
  --hostname=ruby-hello-world.lifecycle.cloudapps-${guid}.oslab.opentlc.com

----


. Take a look at the current `BuildConfig` for our application:
+
----

[marina@master00~]$ oc get buildconfig ruby-hello-world -o yaml

----

. Expect output similar to the following
+
----

apiVersion: v1
kind: BuildConfig
metadata:
  creationTimestamp: 2015-07-11T03:44:43Z
  name: ruby-hello-world
  namespace: lifecycle
  resourceVersion: "10546"
  selfLink: /osapi/v1beta3/namespaces/lifecycle/buildconfigs/ruby-hello-world
  uid: 2ad8d8bc-277f-11e5-a5f8-2cc260072896
spec:
  output:
    to:
      kind: ImageStreamTag
      name: ruby-hello-world:latest
  resources: {}
  source:
    git:
      uri: https://github.com/openshift/ruby-hello-world
    type: Git
  strategy:
    dockerStrategy:
      from:
        kind: ImageStreamTag
        name: ruby-20-centos7:latest
    type: Docker
  triggers:
  - github:
      secret: jV5Ipwr7__4ae_sZG2Jm
    type: GitHub
  - generic:
      secret: ALNUyArydLb22JqdXYIb
    type: Generic
  - imageChange:
      lastTriggeredImageID: openshift/ruby-20-centos7:latest
    type: ImageChange
status:
  lastVersion: 1

----
+

. As you can see, the current configuration points at the `openshift/ruby-hello-world` repository. Since you've forked this repo, let's go ahead and re-point our configuration.

. Use `oc edit` to re-point the configuration:
+
----

[marina@master00~]$  oc edit bc ruby-hello-world

----

. Change the "uri" reference to match the name of your Github
repository. For example if your github user is `jeandeaux`, you would point it
to `https://github.com/jeandeaux/ruby-hello-world`.

. Save and exit (:wq in vi)

WARNING: Please do not use `jeandeaux` as your user name, this needs to be you actual
GitHub user. for example, `https://github.com/<mylogin>/ruby-hello-world`

. If you again run `oc get buildconfig ruby-hello-world -o yaml` you should see
that the `uri` has been updated.

. Run `oc get builds` to see if the new build has started:
+
----
[marina@master00~]$ oc get builds
----

. If a build has not started yet, you can start it yourself and follow the build-log:
+
----
[marina@master00~]$ oc get bc
NAME               TYPE      SOURCE
ruby-hello-world   Docker    https://github.com/YOURUSERNAME/ruby-hello-world

[marina@master00~]$ oc start-build ruby-hello-world
ruby-hello-world-2

[marina@master00~]$ watch oc get builds
NAME                 TYPE      STATUS     POD
ruby-hello-world-1   Source    Complete   ruby-hello-world-1-build
ruby-hello-world-2   Source    Complete   ruby-hello-world-2-build

[marina@master00~]$ oc build-logs ruby-hello-world-X # Replace X with proper number from oc start-build output
I0709 23:41:08.493756       1 docker.go:69] Starting Docker build from justanother1/ruby-hello-world-7 BuildConfig ...
I0709 23:41:08.508448       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.gitignore as .gitignore
I0709 23:41:08.509588       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.sti/bin/README as .sti/bin/README
I0709 23:41:08.509953       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.sti/environment as .sti/environment
I0709 23:41:08.510183       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/Dockerfile as Dockerfile
I0709 23:41:08.510548       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/Gemfile as Gemfile
.......
Cropped Output
.......
----

. Create a file called *mysql-template.json*:
+
----
[marina@master00 ~]$ cat << EOF > mysql-template.json
{
  "kind": "Template",
  "apiVersion": "v1",
  "metadata": {
    "name": "mysql-ephemeral",
    "creationTimestamp": null,
    "annotations": {
      "description": "MySQL database service, without persistent storage. WARNING: Any data stored will be lost upon pod destruction. Only use this template for testing",
      "iconClass": "icon-mysql-database",
      "tags": "database,mysql"
    }
  },
  "objects": [
    {
      "kind": "Service",
      "apiVersion": "v1",
      "metadata": {
        "name": "\${DATABASE_SERVICE_NAME}",
        "creationTimestamp": null
      },
      "spec": {
        "ports": [
          {
            "name": "mysql",
            "protocol": "TCP",
            "port": 3306,
            "targetPort": 3306,
            "nodePort": 0
          }
        ],
        "selector": {
          "name": "\${DATABASE_SERVICE_NAME}"
        },
        "portalIP": "",
        "type": "ClusterIP",
        "sessionAffinity": "None"
      },
      "status": {
        "loadBalancer": {}
      }
    },
    {
      "kind": "DeploymentConfig",
      "apiVersion": "v1",
      "metadata": {
        "name": "\${DATABASE_SERVICE_NAME}",
        "creationTimestamp": null
      },
      "spec": {
        "strategy": {
          "type": "Recreate",
          "resources": {}
        },
        "triggers": [
          {
            "type": "ImageChange",
            "imageChangeParams": {
              "automatic": true,
              "containerNames": [
                "mysql"
              ],
              "from": {
                "kind": "ImageStreamTag",
                "name": "mysql:latest",
                "namespace": "openshift"
              },
              "lastTriggeredImage": ""
            }
          },
          {
            "type": "ConfigChange"
          }
        ],
        "replicas": 1,
        "selector": {
          "name": "\${DATABASE_SERVICE_NAME}"
        },
        "template": {
          "metadata": {
            "creationTimestamp": null,
            "labels": {
              "name": "\${DATABASE_SERVICE_NAME}"
            }
          },
          "spec": {
            "containers": [
              {
                "name": "mysql",
                "image": "mysql",
                "ports": [
                  {
                    "containerPort": 3306,
                    "protocol": "TCP"
                  }
                ],
                "env": [
                  {
                    "name": "MYSQL_USER",
                    "value": "\${MYSQL_USER}"
                  },
                  {
                    "name": "MYSQL_PASSWORD",
                    "value": "\${MYSQL_PASSWORD}"
                  },
                  {
                    "name": "MYSQL_DATABASE",
                    "value": "\${MYSQL_DATABASE}"
                  }
                ],
                "resources": {},
                "terminationMessagePath": "/dev/termination-log",
                "imagePullPolicy": "IfNotPresent",
                "capabilities": {},
                "securityContext": {
                  "capabilities": {},
                  "privileged": false
                }
              }
            ],
            "restartPolicy": "Always",
            "dnsPolicy": "ClusterFirst"
          }
        }
      },
      "status": {}
    }
  ],
  "parameters": [
    {
      "name": "DATABASE_SERVICE_NAME",
      "description": "Database service name",
      "value": "mysql"
    },
    {
      "name": "MYSQL_USER",
      "description": "Username for MySQL user that will be used for accessing the database",
      "generate": "expression",
      "from": "user[A-Z0-9]{3}"
    },
    {
      "name": "MYSQL_PASSWORD",
      "description": "Password for the MySQL user",
      "generate": "expression",
      "from": "[a-zA-Z0-9]{16}"
    },
    {
      "name": "MYSQL_DATABASE",
      "description": "Database name",
      "value": "sampledb"
    }
  ],
  "labels": {
    "template": "mysql-ephemeral-template"
  }
}
EOF

----

. Lets start the *database* service, This time we will do it a little differently:
.. Notice how we are providing the values and processing the *mysql-template.json* file.
.. The *oc process* command output can be saved into a file or "piped" into the *oc create* command
+
----
[marina@master00~]$ oc process -f mysql-template.json \
  --value="MYSQL_USER=root,MYSQL_PASSWORD=redhat,MYSQL_DATABASE=mydb,DATABASE_SERVICE_NAME=database" | \
  tee mysql-processed.json
[marina@master00~]$ oc create -f  mysql-processed.json
----
. *Or* we can process the template, add our variables and "pipe" the output directly to the *oc create* command
.. Note that we are providing the *MYSQL_* attibutes, but also choosing the name of the *service* to be created.
+
----
[marina@master00~]$ oc process -f mysql-template.json --value="MYSQL_USER=root,MYSQL_PASSWORD=redhat,MYSQL_DATABASE=mydb,DATABASE_SERVICE_NAME=database" | oc create -f -
----

. Check that your values were processed correctly
+
----
[marina@master00~]$ oc env dc/database --list
----
+
----
# deploymentconfigs mysql, container mysql
MYSQL_USER=root
MYSQL_PASSWORD=redhat
MYSQL_DATABASE=mydb
----

. Your frontend needs to be "redeployed" so it checks for the DB again.
+
----
[marina@master00-GUID ~]$ oc deploy ruby-hello-world --latest
----

== Lab: Using Webhooks

=== Create a Webhook

Webhooks are a way to integrate external systems into your OpenShift
environment so that they can fire off OpenShift builds. Generally
speaking, one would make code changes, update the code repository, and
then some process would hit OpenShift's webhook URL in order to start
a build with the new code.

Your GitHub account has the capability to configure a webhook to request
whenever a commit is pushed to a specific branch;

. To find the webhook URL, you can visit the web console, click into the
project, click on *Browse* and then on *Builds*. You'll see two webhook
URLs.

. Copy the *Generic* one. It should look like:
+
----
https://master00-GUID.oslab.opentlc.com:8443/osapi/v1/namespaces/lifecycle/buildconfigs/ruby-hello-world/webhooks/ALNUyArydLb22JqdXYIb/generic
----

. Get the *secret* password from the *BuildConfig*
+
----
[marina@master00~]$ oc get bc ruby-hello-world -o yaml
----

. It will look similar to this output, use the "secret" value in your configuration in git.
+
----
.... Cropped Output ....
  triggers:
  - github:
      secret: xTah2lioO2Bz9JZT9dPf
    type: GitHub
  - generic:
      secret: B5h3ARS88HD7S3LOcbRZ
    type: Generic
.... Cropped Output ....
----

. In your Github repo that you forked go to settings -> webhooks and services

. Paste the URL copied from the OpenShift GUI into the Payload URL field.

. Complete the secret field and disable SSL verification.

. Click "add Webhook".

=== Test your WebHook

We want to make a change to the code, then, commit and push the change into the git repository.
+
NOTE: If you know how, you can do this "the normal way" but cloning your repo locally, making changes and pushing them to the repo.
+
. Github's web interface will let you make edits to files. Go to your forked
repository (eg: https://github.com/marina/ruby-hello-world), and find the file `main.erb` in the `views` folder.

. Change the following HTML:
+
----

    <div class="page-header" align=center>
      <h1> Welcome to an OpenShift v3 Demo App! </h1>
    </div>

----
+
To read (with the typo):
+
----

    <div class="page-header" align=center>
      <h1> This is my crustom demo! </h1>
    </div>

----

. When finished changing your code, commit the change to the repo.
. Now check if a build has been triggered.

CAUTION: If a build is currently running, your latest build might fail because
both builds are pushing to our registry, stop the older build (oc delete build)
or retry the failed build. (oc start-build )

. You can also check the web interface (logged in as `marina`) and see
that the build is running. Once it is complete, point your web browser
at the application: link:http://ruby-hello-world.lifecycle.cloudapps-GUID.oslab.opentlc.com/[http://ruby-hello-world.lifecycle.cloudapps-GUID.oslab.opentlc.com/]

+
You should see your big fat typo.
+
[NOTE]
Remember that it can take a minute for your service endpoint to get
updated. You might get a `503` error if you try to access the application before
this happens.


=== Rollback

Since we failed to properly test our application, and our ugly typo has made it
into production, a nastygram from corporate marketing has told us that we need
to revert to the previous version, ASAP.

. If you log into the web console as `marina` and find the `Deployments` section of
the `Browse` menu, you'll see that there are two deployments of our frontend: 1
and 2.

. You can also see this information from the cli by doing:
+
----

[marina@master00~]$ oc get replicationcontroller

----
+
The semantics of this are that a `DeploymentConfig` ensures a
`ReplicationController` is created to manage the deployment of the built `Image`
from the `ImageStream`.


You can rollback a deployment using the CLI.
. Check which builds you have available
+
----
[marina@master00~] oc get builds

----
. Choose a deployment and, check out what a rollback to`ruby-hello-world-#` would look like:
+
----

[marina@master00~]$ oc rollback ruby-hello-world-X --dry-run # X is your desired deployment
Name:           ruby-hello-world
Created:        39 minutes ago
Labels:         <none>
Latest Version: 9
Triggers:       Config, Image(ruby-hello-world@latest, auto=false)
Strategy:       Recreate
Template:
                        Selector:       deploymentconfig=ruby-hello-world
                        Replicas:       1
                        Containers:
                                NAME                    IMAGE                                                     ENV
                                ruby-hello-world        172.30.119.73:5000/lifecycle/ruby-hello-world@sha256:fcc9ce95e503429926dbe9e0cde304e0a0de19483e1cb79acada7334d7eb2504      MYSQL_DATABASE=mydb,MYSQL_PASSWORD=redhat,MYSQL_USER=root
Latest Deployment:      <none>

----

. Since it looks OK, let's go ahead and do it:
+
----

[marina@master00~]$ oc rollback ruby-hello-world-X # X is your desired deployment
#oc get9 rolled back to ruby-hello-world-X
Warning: the following images triggers were disabled: ruby-hello-world
  You can re-enable them with: oc deploy ruby-hello-world --enable-triggers

----
+
If you look at the `Browse` tab of your project, you'll see that in the `Pods`
section there is a new pod now. After a few moments, revisit the
application in your web browser, and you should see the old "Welcome..." text.

=== Roll Back/Forward

. Corporate marketing called again. They think the typo makes us look hip and
cool. Let's now roll forward (activate) the typo-enabled application:
+
----

[marina@master00~]$ oc rollback ruby-hello-world-X # X is your desired deployment
#11 rolled back to ruby-hello-world-X
Warning: the following images triggers were disabled: ruby-hello-world
  You can re-enable them with: oc deploy ruby-hello-world --enable-triggers

----

== Lab: Customized Build and Run Processes

OpenShift v3 supports customization of both the build and run processes.
Generally speaking, this involves modifying the various S2I scripts from the
builder image. When OpenShift builds your code, it checks to see if any of the
scripts in the `.sti/bin` folder of your repository override/supercede the
builder image's scripts. If so, it will execute the repository script instead.

More information on the scripts, their execution during the process, and
customization can be found here:

    https://docs.openshift.org/latest/creating_images/overview.html

=== Add a Script

. In a new tab in your web browser open the following URL and copy all of the text:
+
----
http://www.opentlc.com/download/ose_implementation/resources/custom-assemble.sh
----

. Go to your Github repository for your application from the previous lab.

. In the Github web GUI navigate to the `.sti/bin` folder.

. Click the "+" button at the top (to the right of `bin` in the breadcrumbs).

. Name your file `assemble`.

. In the GitHub GUI paste the contents you copied earlier into the text area.

. Provide a nifty commit message.

. Click the "commit" button.
+
[NOTE]
If you know how to Git(hub), you can do this via your shell.

. Once the file is added, we can now do another build. The "custom" assemble
script will log some extra data.


=== Watch the Build Logs

. Using the skills you have learned, watch the build logs for this build. If you
miss them, remember that you can find the Docker container that ran the build
and look at its Docker logs.

. Did You See It?
+
----

2015-03-11T14:57:00.022957957Z I0311 10:57:00.022913       1 sti.go:357]
---> CUSTOM S2I ASSEMBLE COMPLETE

----
+
But where's the output from the custom `run` script? The `assemble` script is
run inside of your builder pod. That's what you see by using `build-logs` - the
output of the assemble script. The
`run` script actually is what is executed to "start" your application's pod. In
other words, the `run` script is what starts the Ruby process for an image that
was built based on the `ruby-20-rhel7` S2I builder.

. To look inside the builder pod, as `marina`:
+
----

[marina@master00~]$ oc logs `oc get pod | grep -e "[0-9]-build" | tail -1 | awk {'print $1'}` | grep CUSTOM

----
+
You should see something similar to:
+
----

2015-04-27T22:23:24.110630393Z ---> CUSTOM S2I ASSEMBLE COMPLETE

----
