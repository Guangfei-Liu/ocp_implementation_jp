:scrollbar:
:data-uri:
:icons: images/icons
:toc2:		

:numbered:

== Code Lifecycle

=== Connect to Lab

. If not already connected, connect to your administration host:
+
----

yourdesktop$ ssh -i ~/.ssh/id_rsa your-opentlc-login@oselab-GUID.oslab.opentlc.com

----

. SSH to the master host:
+
----
[root@oselab-GUID ~]# ssh root@master00-GUID.oslab.opentlc.com
----
+
[NOTE]
If prompted for a password use *r3dh4t1!*
+
----

root@master00-GUID.oslab.opentlc.com's password: ******** (r3dh4t1!) 

----
		
== Rollback/Activate and Code Lifecycle

Not every coder is perfect, and sometimes you want to rollback to a previous
incarnation of your application. Sometimes you then want to go forward to a
newer version, too.

The next few labs require that you have a Github account. We will take Marina's
"wiring" application and modify its front-end and then rebuild. We'll roll-back
to the original version, and then go forward to our re-built version.

=== Fork the Repository

. Using the git web interface, fork the following git repo: link:https://github.com/sborenst/ruby-hello-world[https://github.com/sborenst/ruby-hello-world]

. Fork this into your own account by clicking the *Fork* Button at
the upper right corner of the Github web UI.

=== Create your application

NOTE: Remember that a `BuildConfig`(uration) tells OpenShift how to do a build.

. As Root (Or Marina), Create a project for Marina to work with:
+
----
[marina@master00-GUID ~]$ oadm new-project lifecycle --display-name="Lifecycle Lab" \
    --description="This is the project we use to learn about Lifecycle management" \
    --admin=marina --node-selector='region=primary'
----

. Switch to Marina and use the *"lifecycle"* project.
+
----
[marina@master00-GUID ~]$ oc project lifecycle 
----

. Lets create an app based on the link:https://github.com/sborenst/ruby-hello-world[https://github.com/sborenst/ruby-hello-world] repo
+
----
[marina@master00-GUID ~]$ oc new-app https://github.com/sborenst/ruby-hello-world
----
+
NOTE: You could have, of course, started the new-app with your own repo, we are only picking the "wrong" one as part of the learning exercise. 

. Since we know that we want to talk to a database eventually, let's take a moment to add the environment variables for it. Conveniently, there is an env subcommand to oc. As marina, we can use it like so:
+
----
[marina@master00-cfe3 ~]$ oc env dc/ruby-hello-world MYSQL_USER=root MYSQL_PASSWORD=redhat MYSQL_DATABASE=mydb
----

. While we wait for the build to finish, lets *expose* our service to the world so we can test this from our local browser:
+

----
[marina@master00-GUID ~]$ oc expose service ruby-hello-world --name="ruby-hello-world" --hostname=ruby-hello-world.lifecycle.cloudapps-$guid.oslab.opentlc.com

----


. Take a look at the current `BuildConfig` for our application:
+
----

[marina@master00-GUID ~]$ oc get buildconfig ruby-hello-world -o yaml

----

. Expect output similar to the following
+
----

apiVersion: v1
kind: BuildConfig
metadata:
  creationTimestamp: 2015-07-10T01:26:25Z
  name: ruby-hello-world
  namespace: lifecycle
  resourceVersion: "91786"
  selfLink: /osapi/v1beta3/namespaces/justanother1/buildconfigs/ruby-hello-world
  uid: ae290227-26a2-11e5-8b7a-2cc260072896
spec:
  output:
    to:
      kind: ImageStreamTag
      name: ruby-hello-world:latest
  resources: {}
  source:
    git:
      uri: https://github.com/sborenst/ruby-hello-world.git
    type: Git
  strategy:
    dockerStrategy:
      from:
        kind: ImageStreamTag
        name: ruby:latest
        namespace: openshift
    type: Docker
  triggers:
  - github:
      secret: xTah2lioO2Bz9JZT9dPf
    type: GitHub
  - generic:
      secret: B5h3ARS88HD7S3LOcbRZ
    type: Generic
  - imageChange:
      lastTriggeredImageID: registry.access.redhat.com/openshift3/ruby-20-rhel7:latest
    type: ImageChange
status:
  lastVersion: 4

----
+

. As you can see, the current configuration points at the `sborenst/ruby-hello-world` repository. Since you've forked this repo, let's go ahead and re-point our configuration. 

. Use `oc edit` to re-point the configuration:
+
----

[marina@master00-GUID ~]$  oc edit bc ruby-hello-world

----

. Change the "uri" reference to match the name of your Github
repository. Assuming your github user is `marina`, you would point it
to `git://github.com/marina/ruby-hello-world.git`. Save and exit
the editor.

. If you again run `oc get buildconfig ruby-hello-world -o yaml` you should see
that the `uri` has been updated.

. Check to see if a new build has been created:
+
----
[marina@master00-GUID ~]$  oc get builds
----

. If a build has not started yet, you can start it yourself and follow the build-log:
+
----
[marina@master00-GUID ~]$ oc get bc 
NAME               TYPE      SOURCE
ruby-hello-world   Docker    https://github.com/marina/ruby-hello-world.git

[marina@master00-GUID ~]$ oc start-build ruby-hello-world
ruby-hello-world-7

[marina@master00-GUID ~]$ oc get builds
NAME                 TYPE      STATUS     POD
ruby-hello-world-5   Docker    Complete   ruby-hello-world-5-build
ruby-hello-world-6   Docker    Complete   ruby-hello-world-6-build
ruby-hello-world-7   Docker    Running    ruby-hello-world-7-build

[marina@master00-GUID ~]$ oc build-logs ruby-hello-world-7
I0709 23:41:08.493756       1 docker.go:69] Starting Docker build from justanother1/ruby-hello-world-7 BuildConfig ...
I0709 23:41:08.508448       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.gitignore as .gitignore
I0709 23:41:08.509588       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.sti/bin/README as .sti/bin/README
I0709 23:41:08.509953       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.sti/environment as .sti/environment
I0709 23:41:08.510183       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/Dockerfile as Dockerfile
I0709 23:41:08.510548       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/Gemfile as Gemfile
.......
Cropped Output
.......
----

. Lets start the *database* service, This time we will do it a little differently:
.. Notice how we are providing the values and processing the *mysql-template.json* file. 
.. The *oc process* command output can be saved into a file or "piped" into the *oc create* command
+
----
[marina@master00-GUID ~]$ oc process -f mysql-template.json --value="MYSQL_USER=root,MYSQL_PASSWORD=redhat,MYSQL_DATABASE=mydb" | tee mysql-processed.json
[marina@master00-GUID ~]$ oc create -f  mysql-processed.json
----
. *Or* we can process the template, add our variables and "pipe" the output directly to the *oc create* command
.. Note that we are providing the *MYSQL_* attibutes, but also choosing the name of the *service* to be created.
+
----
[marina@master00-GUID ~]$ oc process -f mysql-template.json --value="MYSQL_USER=root,MYSQL_PASSWORD=redhat,MYSQL_DATABASE=mydb,DATABASE_SERVICE_NAME=database" | oc create -f -
---- 

. Check that your values were processed correctly
+
----
[marina@master00-cfe3 ~]$ oc env dc/mysql --list
# deploymentconfigs mysql, container mysql
MYSQL_USER=root
MYSQL_PASSWORD=redhat
MYSQL_DATABASE=mydb
----

INFO: Your frontend needs to be "redeployed" so it checked for the DB again.

== Using Webhooks

=== Create a Webhook

Webhooks are a way to integrate external systems into your OpenShift
environment so that they can fire off OpenShift builds. Generally
speaking, one would make code changes, update the code repository, and
then some process would hit OpenShift's webhook URL in order to start
a build with the new code.

Your GitHub account has the capability to configure a webhook to request
whenever a commit is pushed to a specific branch; 

. To find the webhook URL, you can visit the web console, click into the
project, click on *Browse* and then on *Builds*. You'll see two webhook
URLs. 

. Copy the *Generic* one. It should look like:
+
----
https://master00-cfe3.oslab.opentlc.com:8443/osapi/v1beta3/namespaces/justanother1/buildconfigs/ruby-hello-world/webhooks/B5h3ARS88HD7S3LOcbRZ/generic
----

. Get the *secret* password from the *BuildConfig*
+
----
[marina@master00-GUID ~]$ oc get bc ruby-hello-world -o yaml
----

. It will similar to this output, use the "secret" value in your configuration in git.
+
----
.... Cropped Output .... 
  triggers:
  - github:
      secret: xTah2lioO2Bz9JZT9dPf
    type: GitHub
  - generic:
      secret: B5h3ARS88HD7S3LOcbRZ
    type: Generic
.... Cropped Output ....
----

. Complete the configuration on Github.

=== Test your WebHook

We want to make a change to the code, then, commit and push the change into the git repository.
+
NOTE: If you know how, you can do this "the normal way" but cloning your repo locally, making changes and pushing them to the repo.
+
. Github's web interface will let you make edits to files. Go to your forked
repository (eg: https://github.com/marina/ruby-hello-world), and find the file `main.erb` in the `views` folder.

. Change the following HTML:
+
----

    <div class="page-header" align=center>
      <h1> Welcome to an OpenShift v3 Demo App! </h1>
    </div>
    
----
+
To read (with the typo):
+
----

    <div class="page-header" align=center>
      <h1> This is my crustom demo! </h1>
    </div>

----

. When finished changing your code, commit the change to the repo. 
. Now check if a build has been triggered. 
. You can also check the web interface (logged in as `marina`) and see
that the build is running. Once it is complete, point your web browser
at the application: link:http://ruby-hello-world.lifecycle.cloudapps-GUID.oslab.opentlc.com/[http://ruby-hello-world.lifecycle.cloudapps-GUID.oslab.opentlc.com/]

+
You should see your big fat typo.
+
[NOTE]
Remember that it can take a minute for your service endpoint to get
updated. You might get a `503` error if you try to access the application before
this happens.
+
Since we failed to properly test our application, and our ugly typo has made it
into production, a nastygram from corporate marketing has told us that we need
to revert to the previous version, ASAP.

. If you log into the web console as `marina` and find the `Deployments` section of
the `Browse` menu, you'll see that there are two deployments of our frontend: 1
and 2.

. You can also see this information from the cli by doing:
+
----

[marina@master00-GUID ~]$ oc get replicationcontroller

----
+
The semantics of this are that a `DeploymentConfig` ensures a
`ReplicationController` is created to manage the deployment of the built `Image`
from the `ImageStream`.

=== Rollback

You can rollback a deployment using the CLI. 
. Check which builds you have available 
+
----
[marina@master00-GUID ~] oc get builds 

----
. Choose a deployment and, check out what a rollback to`ruby-hello-world-#` would look like:
+
----

[marina@master00-GUID ~]$ oc rollback ruby-hello-world-2 --dry-run

----

. Since it looks OK, let's go ahead and do it:
+
----

[marina@master00-GUID ~]$ oc rollback ruby-hello-world-2

----
+
If you look at the `Browse` tab of your project, you'll see that in the `Pods`
section there is a `frontend-3...` pod now. After a few moments, revisit the
application in your web browser, and you should see the old "Welcome..." text.

=== Roll Back/Forward

. Corporate marketing called again. They think the typo makes us look hip and
cool. Let's now roll forward (activate) the typo-enabled application:
+
----

[marina@master00-GUID ~]$ oc rollback ruby-hello-world-3

----

== Customized Build and Run Processes

OpenShift v3 supports customization of both the build and run processes.
Generally speaking, this involves modifying the various S2I scripts from the
builder image. When OpenShift builds your code, it checks to see if any of the
scripts in the `.sti/bin` folder of your repository override/supercede the
builder image's scripts. If so, it will execute the repository script instead.

More information on the scripts, their execution during the process, and
customization can be found here:

    http://docs.openshift.org/latest/creating_images/sti.html#sti-scripts

=== Add a Script

. Go to your Github repository for your application from the previous lab.

. In the Github web GUI

. Navigate to the `.sti/bin` folder.

. Click the "+" button at the top (to the right of `bin` in the breadcrumbs).

. Name your file `assemble`.

. On the master host command line find the script called `custom-assemble.sh` in the `resources` folder and paste the contents of `custom-assemble.sh` into the text area.

. Provide a nifty commit message.

. Click the "commit" button.
+
[NOTE]
If you know how to Git(hub), you can do this via your shell.

. Once the file is added, we can now do another build. The "custom" assemble
script will log some extra data.


=== Watch the Build Logs

. Using the skills you have learned, watch the build logs for this build. If you
miss them, remember that you can find the Docker container that ran the build
and look at its Docker logs.

. Did You See It?
+
----

2015-03-11T14:57:00.022957957Z I0311 10:57:00.022913       1 sti.go:357]
---> CUSTOM S2I ASSEMBLE COMPLETE

----
+
But where's the output from the custom `run` script? The `assemble` script is
run inside of your builder pod. That's what you see by using `build-logs` - the
output of the assemble script. The
`run` script actually is what is executed to "start" your application's pod. In
other words, the `run` script is what starts the Ruby process for an image that
was built based on the `ruby-20-rhel7` S2I builder. 

. To look inside the builder pod, as `marina`:
+
----

[marina@master00-GUID ~]$ oc logs `oc get pod | grep -e "[0-9]-build" | tail -1 | awk {'print $1'}` | grep CUSTOM

----
+
You should see something similar to:
+
----

2015-04-27T22:23:24.110630393Z ---> CUSTOM S2I ASSEMBLE COMPLETE

----

== Lifecycle Pre and Post Deployment Hooks

Like in OpenShift 2, we have the capability of "hooks" - performing actions both
before and after the **deployment**. In other words, once an S2I build is
complete, the resulting Docker image is pushed into the registry. Once the push
is complete, OpenShift detects an `ImageChange` and, if so configured, triggers
a **deployment**.

The *pre*-deployment hook is executed just *before* the new image is deployed.

The *post*-deployment hook is executed just *after* the new image is deployed.

How is this accomplished? OpenShift will actually spin-up an *extra* instance of
your built image, execute your hook script(s), and then shut the instance down.
Neat, huh?

Since we already have our `wiring` app pointing at our forked code repository,
let's go ahead and add a database migration file. In the `beta4` folder you will
find a file called `1_sample_table.rb`. Add this file to the `db/migrate` folder
of the `ruby-hello-world` repository that you forked. If you don't add this file
to the right folder, the rest of the steps will fail.

=== Examining Deployment Hooks

Take a look at the following JSON:

    "strategy": {
        "type": "Recreate",
        "resource": {},
        "recreateParams": {
            "pre": {
                "failurePolicy": "Abort",
                "execNewPod": {
                    "command": [
                        "/bin/true"
                    ],
                    "env": [
                        {
                            "name": "CUSTOM_VAR1",
                            "value": "custom_value1"
                        }
                    ],
                    "containerName": "ruby-helloworld"
                }
            },
            "post": {
                "failurePolicy": "Ignore",
                "execNewPod": {
                    "command": [
                        "/bin/false"
                    ],
                    "env": [
                        {
                            "name": "CUSTOM_VAR2",
                            "value": "custom_value2"
                        }
                    ],
                    "containerName": "ruby-helloworld"
                }
            }
        }
    },

You can see that both a *pre* and *post* deployment hook are defined. They don't
actually do anything useful. But they are good examples.

The pre-deployment hook executes "/bin/true" whose exit code is always 0 --
success. If for some reason this failed (non-zero exit), our policy would be to
`Abort` -- consider the entire deployment a failure and stop.

The post-deployment hook executes "/bin/false" whose exit code is always 1 --
failure. The policy is to `Ignore`, or do nothing. For non-essential tasks that
might rely on an external service, this might be a good policy.

More information on these strategies, the various policies, and other
information can be found in the documentation:

    http://docs.openshift.org/latest/dev_guide/deployments.html

=== Modifying the Hooks

. Since we are talking about **deployments**, let's look at our
`DeploymentConfig`s. As the `marina` user in the `wiring` project:
+
----

[marina@master00-GUID ~]$ oc get dc

----
+
You should see something like:
+
----

NAME               TRIGGERS                    LATEST VERSION
database           Change, ConfigChange        1
ruby-hello-world   ConfigChange, ImageChange   6


----

. Since we are trying to associate a Rails database migration hook with our
application, we are ultimately talking about a deployment of the frontend (ruby-hello-world). If
you edit the ruby-hello-world's `DeploymentConfig` as `marina`:
+
----

[marina@master00-GUID ~]$ oc edit dc ruby-hello-world -o json

----

. Yes, the default for `oc edit` is to use YAML. For this exercise, JSON will be
easier as it is indentation-insensitive. Find the section that looks like the
following before continuing:
+
----

    "spec": {
        "strategy": {
            "type": "Recreate",
            "resources": {}
        },

----

A Rails migration is commonly performed when we have added/modified the database
as part of our code change. In the case of a pre- or post-deployment hook, it
would make sense to:

* Attempt to migrate the database

* Abort the new deployment if the migration fails

Otherwise we could end up with our new code deployed but our database schema
would not match. This could be a *Real Bad Thing (TM)*.

In the case of the `ruby-20` builder image, we are actually using RHEL7 and the
Red Hat Software Collections (SCL) to get our Ruby 2.0 support. So, the command
we want to run looks like:

    /usr/bin/scl enable ruby200 ror40 'cd /opt/openshift/src ; bundle exec rake db:migrate'

This command:

* executes inside an SCL "shell"

* enables the Ruby 2.0.0 and Ruby On Rails 4.0 environments

* changes to the `/opt/openshift/src` directory (where our applications' code is
    located)
    
* executes `bundle exec rake db:migrate`

If you're not familiar with Ruby, Rails, or Bundler, that's OK.

The `command` directive inside the hook's definition tells us which command to
actually execute. It is required that this is an array of individual strings.
Represented in JSON, our desired command above represented as a string array
looks like:

    "command": [
        "/usr/bin/scl",
        "enable",
        "ruby200",
        "ror40",
        "cd /opt/openshift/src ; bundle exec rake db:migrate"
    ]

This is great, but actually manipulating the database requires that we talk
**to** the database. Talking to the database requires a user and a password.
Smartly, our hook pods inherit the same environment variables as the main
deployed pods, so we'll have access to the same datbase information.

Looking at the original hook example in the previous section, and our command
reference above, in the end, you will have something that looks like:

    "strategy": {
        "type": "Recreate",
        "resources": {},
        "recreateParams": {
            "pre": {
                "failurePolicy": "Abort",
                "execNewPod": {
                    "command": [
                        "/usr/bin/scl",
                        "enable",
                        "ruby200",
                        "ror40",
                        "cd /opt/openshift/src ; bundle exec rake db:migrate"
                    ],
                    "containerName": "ruby-helloworld"
                }
            },
        }
    },

Remember, indentation isn't critical in JSON, but closing brackets and braces
are. When you are done editing the deployment config, save and quit your editor.

=== Quickly Clean Up

When we did our previous builds and rollbacks and etc, we ended up with a lot of
stale pods that are not running (`Succeeded`). Currently we do not auto-delete
these pods because we have no log store -- once they are deleted, you can't view
their logs any longer.

. For now, we can clean up by doing the following as `marina`:
+
----

[marina@master00-GUID ~]$ oc get pod | grep -E "[0-9]-build" |\
   awk {'print $1'} | xargs -r oc delete pod

----

This will get rid of all of our old build and lifecycle pods. The lifecycle pods
are the pre- and post-deployment hook pods, and the sti-build pods are the pods
in which our previous builds occurred.

=== Build Again

Now that we have modified the deployment configuration and cleaned up a bit, we
need to trigger another deployment. While killing the frontend pod would trigger
another deployment, our current Docker image doesn't have the database migration
file in it. Nothing really useful would happen.

In order to get the database migration file into the Docker image, we actually
need to do another build. Remember, the S2I process starts with the builder
image, fetches the source code, executes the (customized) assemble script, and
then pushes the resulting Docker image into the registry. **Then** the
deployment happens.

. As `marina`:
+
----

[marina@master00-GUID ~]$ oc start-build ruby-hello-world

----
+
Or go into the web console and click the "Start Build" button in the Builds
area.

=== Verify the Migration

. About a minute after the build completes, you should see something like the following output
of `oc get pod` as `marina`:
+
----

[marina@master00-GUID ~]$ oc get pod

----
+
----

POD                                IP          CONTAINER(S)               IMAGE(S)                                                                                                                HOST                                    LABELS                                                                                                                  STATUS       CREATED         MESSAGE
database-2-rj72q                   10.1.0.15                                                                                                                                                      master00-GUID.oslab.opentlc.com/192.168.133.2   deployment=database-2,deploymentconfig=database,name=database                                                           Running      About an hour   
                                               ruby-helloworld-database   registry.access.redhat.com/openshift3_beta/mysql-55-rhel7                                                                                                                                                                                                                               Running      About an hour   
deployment-frontend-7-hook-4i8ch                                                                                                                                                                  node00-GUID.oslab.opentlc.com/192.168.133.3    <none>                                                                                                                  Succeeded    41 seconds      
                                               lifecycle                  172.30.118.110:5000/wiring/origin-ruby-sample@sha256:2984cfcae1dd42c257bd2f79284293df8992726ae24b43470e6ffd08affc3dfd                                                                                                                                                                   Terminated   36 seconds      exit code 0
frontend-7-nnnxz                   10.1.1.24                                                                                                                                                      node00-GUID.oslab.opentlc.com/192.168.133.3    deployment=frontend-7,deploymentconfig=frontend,name=frontend                                                           Running      29 seconds      
                                               ruby-helloworld            172.30.118.110:5000/wiring/origin-ruby-sample@sha256:2984cfcae1dd42c257bd2f79284293df8992726ae24b43470e6ffd08affc3dfd                                                                                                                                                                   Running      26 seconds      
ruby-sample-build-7-build                                                                                                                                                                         master00-GUID.oslab.opentlc.com/192.168.133.2   build=ruby-sample-build-7,buildconfig=ruby-sample-build,name=ruby-sample-build,template=application-template-stibuild   Succeeded    2 minutes       
                                               sti-build                  openshift3_beta/ose-sti-builder:v0.5.2.2                                                                                                                                                                                                                                                Terminated   2 minutes       exit code 0

----
+
You'll see that there is a single `hook`/`lifecycle` pod -- this corresponds
with the pod that ran our pre-deployment hook.

. Inspect this pod's logs:
+
----

[marina@master00-GUID ~]$ oc logs deployment-frontend-7-hook-4i8ch

----
+
The output should show something like:
+
----

== 1 SampleTable: migrating ===================================================
-- create_table(:sample_table)
   -> 0.1075s
== 1 SampleTable: migrated (0.1078s) ==========================================

----
+
If you have no output, you may have forgotten to actually put the migration file
in your repo. Without that file, the migration does nothing, which produces no
output.
+
You can even talk directly to the database on its service IP/port
using the `mysql` client and the environment variables (you would need the
`mysql` package installed on your master, for example).

. As `marina`, find your database:
+
----

[marina@master00-GUID ~]$ oc get service
NAME       LABELS    SELECTOR        IP(S)            PORT(S)
database   <none>    name=database   172.30.108.133   5434/TCP
frontend   <none>    name=frontend   172.30.229.16    5432/TCP

----
+
Take note of the database IP and PORT.

. Get database connection info:
+
----

[marina@master00-GUID ~]$ oc get dc database -o yaml | grep -A1 MYSQL

----
+
----

  - name: MYSQL_USER
    value: [username]
  - named: MYSQL_PASSWORD
    value: [password]
  - name: MYSQL_DATABASE
    value: [database]

----

. As root on the master host install the mysql client:
+
----

[root@master00-GUID ~]# yum -y install mariadb

----

. Then use the `mysql` client to connect to this service using the connection information discovered in the earlier steps and dump the table that we created:
+
----

[marina@master00-GUID ~]$ mysql -u[username] \
      -p[password] \
      -h[db_IP] \
      -P[db_PORT] \
      -e'show tables; describe sample_table;' \
      [database]

----
+
----

+-------------------+
| Tables_in_root    |
+-------------------+
| sample_table      |
| key_pairs         |
| schema_migrations |
+-------------------+
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | NO   |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+

----

== Arbitrary Docker Image (Builder)

One of the first things we did with OpenShift was launch an "arbitrary" Docker
image from the Docker Hub. However, we can also build Docker images from Docker
files, too. While this is a "build" process, it's not a "source-to-image"
process -- we're not working with only a source code repo.

As an example, the CentOS community maintains a Wordpress all-in-one Docker
image:

    https://github.com/CentOS/CentOS-Dockerfiles/tree/master/wordpress/centos7

We've taken the content of this subfolder and placed it in the GitHub
`openshift/centos7-wordpress` repository. 

. Run `oc new-app` and see what happens:
+
----

[marina@master00-GUID ~]$ oc new-app https://github.com/openshift/centos7-wordpress.git -o yaml

----

=== Create a Project

. As `marina`, go ahead and create a new project:
+
----

[marina@master00-GUID ~]$ oc new-project wordpress --display-name="Wordpress" \
    --description='Building an arbitrary Wordpress Docker image'

----

=== Build Wordpress

. Let's choose the Wordpress example:
+
----

[marina@master00-GUID ~]$ oc new-app -l name=wordpress https://github.com/openshift/centos7-wordpress.git

----
+
----

imageStreams/centos
imageStreams/centos7-wordpress
buildConfigs/centos7-wordpress
deploymentConfigs/centos7-wordpress
services/centos7-wordpress
A build was created - you can run `oc start-build centos7-wordpress` to start it.
Service "centos7-wordpress" created at 172.30.135.252 with port mappings 22.

----

. Start the build:
+
----

[marina@master00-GUID ~]$ oc start-build centos7-wordpress

----
+
[NOTE]
This can take a *really* long time to build.**

. Fix the json file from the training repo to match the lab hostnames:
+
----

[marina@master00-GUID ~]$ sed -i "s/cloudapps.example.com/cloudapps-$GUID.oslab.opentlc.com/" ~/training/beta4/wordpress-addition.json

----

. You will need a route for this application, as `curl` won't do a whole lot for
us here. Additionally, `oc new-app` currently has a bug in the way services are
detected, so we'll have a service for SSH (thus port 22 above) but not one for
httpd. So we'll add on a service and route for web access.
+
----

[marina@master00-GUID ~]$ cd ~/training/beta4; oc create -f wordpress-addition.json

----

=== Test Your Application

. You should be able to visit:

    http://wordpress.cloudapps-GUID.oslab.opentlc.com

Remember - not only did we use an arbitrary Docker image, we actually built the
Docker image using OpenShift. Technically there was no "code repository". So, if
you allow it, developers can actually simply build Docker containers as their
"apps" and run them directly on OpenShift.

=== Application Resource Labels

You may have wondered about the `-l name=wordpress` in the invocation above. This
applies a label to all of the resources created by `oc new-app` so that they can
be easily distinguished from any other resources in a project. 

. For example, we can easily delete only the things with this label:
+
----

[marina@master00-GUID ~]$ oc delete all -l name=wordpress

----
+
----

buildConfigs/centos7-wordpress
builds/centos7-wordpress-1
imageStreams/centos
imageStreams/centos7-wordpress
deploymentConfigs/centos7-wordpress
replicationcontrollers/centos7-wordpress-1
services/centos7-wordpress

----

. Notice that the things we created from wordpress-addition.json didn't
have this label, so they didn't get deleted:
+
----

[marina@master00-GUID ~]$ oc get services

----
+
----

NAME                      LABELS    SELECTOR                             IP             PORT(S)
wordpress-httpd-service   <none>    deploymentconfig=centos7-wordpress   172.30.17.83   80/TCP

----
+
----

[marina@master00-GUID ~]$ oc get route

----
+
----

NAME              HOST/PORT                         PATH      SERVICE                   LABELS
wordpress-route   wordpress.cloudapps.example.com             wordpress-httpd-service

----

Labels will be useful for many things, including identification in the web console.

== EAP Example

This example requires internet access because the Maven configuration uses
public repositories.

If you have a Java application whose Maven configuration uses local
repositories, or has no Maven requirements, you could probably substitute that
code repository for the one below.

=== Create a Project

Using the skills you have learned earlier in the training, create a new project
for the EAP example. Make sure to use the user that created the project in the subsequent commands.

=== Instantiate the Template
When we imported the imagestreams into the `openshift` namespace earlier, we
also brought in JBoss EAP and Tomcat S2I builder images.

Take a look at the `eap6-basic-sti.json` in the `training/beta4` folder.  You'll see that
there are a number of bash-style variables (`${SOMETHING}`) in use in this
template. This template is already configured to use the EAP builder image, so
we can use the web console to simply isntantiate it in the desired way.

We want to:

* set the application name to *helloworld*

* set the application hostname to *helloworld.cloudapps-GUID.oslab.opentlc.com*

* set the Git URI to *https://github.com/jboss-developer/jboss-eap-quickstarts/*

* set the Git ref to *6.4.x*

* set the Git context dir to *helloworld*

* set Github and Generic trigger secrets to *secret*

. Update the JSON file with the correct domain:
+
----

[marina@master00-GUID ~]$ sed -i "s/cloudapps.example.com/cloudapps-$GUID.oslab.opentlc.com/" ~/training/beta4/eap6-basic-sti.json

----

Ok, we're ready:

. Add the `eap6-basic-sti.json` template to your project using the commandline:
+
----

[marina@master00-GUID ~]$ cd ~training/beta4; oc create -f eap6-basic-sti.json

----

. Create the secret for the EAP template:
+
----

[marina@master00-GUID beta4]$ oc create -f eap-app-secret.json

----

. Go into the web console.

. Find the project you created and click on it.

. Click the "Create..." button.

. Click the "Browse all templates..." button.

. Click the "eap6-basic-sti" example.

. Click "Select template".

. Now that you are on the overview page, you'll have to click "Edit Paremeters"
and fill in the values with the things we wanted above. 

. Hit "Create" when you are done.

In the UI you will see a bunch of things get created -- several services, some
routes, and etc.

=== Update the BuildConfig

The template assumes that the imageStream exists in our current project, but
that is not the case. The EAP imageStream exists in the `openshift` namespace.

. Edit the resulting `buildConfig` and specify that.
+
----

[marina@master00-GUID ~]$ oc edit bc helloworld

----

. You will need to edit the `strategy` section to look like the following:

    strategy:
      sourceStrategy:
        from:
          kind: ImageStreamTag
          name: jboss-eap6-openshift:6.4
          namespace: openshift

**REMEMBER** indentation is *important* in YAML.

=== Watch the Build

In a few moments a build will start. You can watch the build if you choose, or
just look at the web console and wait for it to finish. If you do watch the
build, you might notice some Maven errors.  These are non-critical and will not
affect the success or failure of the build.

=== Visit Your Application

We specified a route via defining the application hostname, so you should be able to
visit your app at:

    http://helloworld.cloudapps-GUID.oslab.opentlc.com/jboss-helloworld

The reason that it is "/jboss-helloworld" and not just "/" is because the
helloworld application does not use a "ROOT.war". If you don't understand this,
it's because Java is confusing.


:numbered!:

