:scrollbar:
:data-uri:
:toc2:
:icons: images/icons

== Manage the Deployment Lifecycle

:numbered:

In this lab you manage the various phases of the deployment lifecycle.

* Roll Back/Activate and Code Lifecycle
* Use Webhooks
* Create Customized Build and Run Processes




== Roll Back/Activate and Code Lifecycle

Because no one always codes perfectly, sometimes you want to roll back to a previous incarnation of your application. And sometimes you want to go forward to a newer version.

The next few labs require you to have a GitHub account. 

In this lab, you take Marina's `wiring` application, modify its front end, and then rebuild. After that, you roll back to the original version, and then go forward to your rebuilt version.

=== Fork the Repository

. Using the Git web interface, fork the following Git repository: https://github.com/openshift/ruby-hello-world.

. To fork this into your own account, click *Fork* in the upper-right corner of the GitHub web UI.

=== Create Your Application

[NOTE]
Remember that `BuildConfig` (Build Configuration) tells OpenShift Enterprise how to do a build.

. As `root`, create a project for user `marina` to work with:
+
----
[root@master00 ~]# oadm new-project lifecycle --display-name="Lifecycle Lab" \
    --description="This is the project we use to learn about Lifecycle management" \
    --admin=marina --node-selector='region=primary'
----

. Switch to user `marina` and use the `lifecycle` project.
+
----
[root@master00 ~]# su - marina
[marina@master00 ~]$ oc login -u marina --insecure-skip-tls-verify --server=https://master00-${guid}.oslab.opentlc.com:8443
[marina@master00 ~]$ oc project lifecycle
----

. Create an application based on the https://github.com/openshift/ruby-hello-world repository.
+
----
[marina@master00~]$ oc new-app https://github.com/openshift/ruby-hello-world --strategy=source
----
+
[NOTE]
====
Note that you are using `--strategy=source` to force `oc new-app` to use the S2I strategy. You could have started the `new-app` with your own repository, but you are intentionally picking the "wrong" repository as part of this learning exercise.
====

. Because you know that you want to talk to a database eventually, use `oc env` to add the environment variables for it now.
+
----
[marina@master00~]$ oc env dc/ruby-hello-world MYSQL_USER=root \
  MYSQL_PASSWORD=redhat MYSQL_DATABASE=mydb
----

. While you wait for the build to finish, `expose` your service to the world so you can test it from your local browser.
+
----
[marina@master00~]$ oc expose service ruby-hello-world \
  --name="ruby-hello-world" \
  --hostname=ruby-hello-world.lifecycle.cloudapps-${guid}.oslab.opentlc.com

----


. Check the current `BuildConfig` for your application.
+
----

[marina@master00~]$ oc get buildconfig ruby-hello-world -o yaml

----

* You will see output similar to the following:
+
----

apiVersion: v1
kind: BuildConfig
metadata:
  creationTimestamp: 2015-07-11T03:44:43Z
  name: ruby-hello-world
  namespace: lifecycle
  resourceVersion: "10546"
  selfLink: /osapi/v1beta3/namespaces/lifecycle/buildconfigs/ruby-hello-world
  uid: 2ad8d8bc-277f-11e5-a5f8-2cc260072896
spec:
  output:
    to:
      kind: ImageStreamTag
      name: ruby-hello-world:latest
  resources: {}
  source:
    git:
      uri: https://github.com/openshift/ruby-hello-world
    type: Git
  strategy:
    dockerStrategy:
      from:
        kind: ImageStreamTag
        name: ruby-20-centos7:latest
    type: Docker
  triggers:
  - github:
      secret: jV5Ipwr7__4ae_sZG2Jm
    type: GitHub
  - generic:
      secret: ALNUyArydLb22JqdXYIb
    type: Generic
  - imageChange:
      lastTriggeredImageID: openshift/ruby-20-centos7:latest
    type: ImageChange
status:
  lastVersion: 1

----

. Observe that the current configuration points at the `openshift/ruby-hello-world` repository. 
* Because you forked this repository, you can now repoint your configuration.

=== Repoint Your Configuration

. Use `oc edit` to repoint the configuration.
+
----

[marina@master00~]$  oc edit bc ruby-hello-world

----

.. Change the `uri` reference to match the name of your GitHub repository. For example if your GitHub user is `jeandeaux`, you would point to `https://github.com/jeandeaux/ruby-hello-world`.
+
[WARNING]
Do not use `jeandeaux` as your username. You need to use your actual GitHub user--for example, `https://github.com/<mylogin>/ruby-hello-world`.


.. Save and enter *:wq* to exit `vi`.


. Run `oc get buildconfig ruby-hello-world -o yaml` again. 
* You should see that the `uri` has been updated.

. Run `oc get builds` to see if the new build has started.
+
----
[marina@master00~]$ oc get builds
----

. If a build has not started yet, you can start it yourself and follow the `build-log`.
+
----
[marina@master00~]$ oc get bc
NAME               TYPE      SOURCE
ruby-hello-world   Docker    https://github.com/YOURUSERNAME/ruby-hello-world

[marina@master00~]$ oc start-build ruby-hello-world
ruby-hello-world-2

[marina@master00~]$ watch oc get builds
NAME                 TYPE      STATUS     POD
ruby-hello-world-1   Source    Complete   ruby-hello-world-1-build
ruby-hello-world-2   Source    Complete   ruby-hello-world-2-build

[marina@master00~]$ oc build-logs ruby-hello-world-X # Replace X with proper number from oc start-build output
I0709 23:41:08.493756       1 docker.go:69] Starting Docker build from justanother1/ruby-hello-world-7 BuildConfig ...
I0709 23:41:08.508448       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.gitignore as .gitignore
I0709 23:41:08.509588       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.sti/bin/README as .sti/bin/README
I0709 23:41:08.509953       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/.sti/environment as .sti/environment
I0709 23:41:08.510183       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/Dockerfile as Dockerfile
I0709 23:41:08.510548       1 tar.go:133] Adding to tar: /tmp/docker-build062004796/Gemfile as Gemfile
.......
Cropped Output
.......
----

. Create a `mysql-template.json` file.
+
----
[marina@master00 ~]$ cat << EOF > mysql-template.json
{
  "kind": "Template",
  "apiVersion": "v1",
  "metadata": {
    "name": "mysql-ephemeral",
    "creationTimestamp": null,
    "annotations": {
      "description": "MySQL database service, without persistent storage. WARNING: Any data stored will be lost upon pod destruction. Only use this template for testing",
      "iconClass": "icon-mysql-database",
      "tags": "database,mysql"
    }
  },
  "objects": [
    {
      "kind": "Service",
      "apiVersion": "v1",
      "metadata": {
        "name": "\${DATABASE_SERVICE_NAME}",
        "creationTimestamp": null
      },
      "spec": {
        "ports": [
          {
            "name": "mysql",
            "protocol": "TCP",
            "port": 3306,
            "targetPort": 3306,
            "nodePort": 0
          }
        ],
        "selector": {
          "name": "\${DATABASE_SERVICE_NAME}"
        },
        "portalIP": "",
        "type": "ClusterIP",
        "sessionAffinity": "None"
      },
      "status": {
        "loadBalancer": {}
      }
    },
    {
      "kind": "DeploymentConfig",
      "apiVersion": "v1",
      "metadata": {
        "name": "\${DATABASE_SERVICE_NAME}",
        "creationTimestamp": null
      },
      "spec": {
        "strategy": {
          "type": "Recreate",
          "resources": {}
        },
        "triggers": [
          {
            "type": "ImageChange",
            "imageChangeParams": {
              "automatic": true,
              "containerNames": [
                "mysql"
              ],
              "from": {
                "kind": "ImageStreamTag",
                "name": "mysql:latest",
                "namespace": "openshift"
              },
              "lastTriggeredImage": ""
            }
          },
          {
            "type": "ConfigChange"
          }
        ],
        "replicas": 1,
        "selector": {
          "name": "\${DATABASE_SERVICE_NAME}"
        },
        "template": {
          "metadata": {
            "creationTimestamp": null,
            "labels": {
              "name": "\${DATABASE_SERVICE_NAME}"
            }
          },
          "spec": {
            "containers": [
              {
                "name": "mysql",
                "image": "mysql",
                "ports": [
                  {
                    "containerPort": 3306,
                    "protocol": "TCP"
                  }
                ],
                "env": [
                  {
                    "name": "MYSQL_USER",
                    "value": "\${MYSQL_USER}"
                  },
                  {
                    "name": "MYSQL_PASSWORD",
                    "value": "\${MYSQL_PASSWORD}"
                  },
                  {
                    "name": "MYSQL_DATABASE",
                    "value": "\${MYSQL_DATABASE}"
                  }
                ],
                "resources": {},
                "terminationMessagePath": "/dev/termination-log",
                "imagePullPolicy": "IfNotPresent",
                "capabilities": {},
                "securityContext": {
                  "capabilities": {},
                  "privileged": false
                }
              }
            ],
            "restartPolicy": "Always",
            "dnsPolicy": "ClusterFirst"
          }
        }
      },
      "status": {}
    }
  ],
  "parameters": [
    {
      "name": "DATABASE_SERVICE_NAME",
      "description": "Database service name",
      "value": "mysql"
    },
    {
      "name": "MYSQL_USER",
      "description": "Username for MySQL user that will be used for accessing the database",
      "generate": "expression",
      "from": "user[A-Z0-9]{3}"
    },
    {
      "name": "MYSQL_PASSWORD",
      "description": "Password for the MySQL user",
      "generate": "expression",
      "from": "[a-zA-Z0-9]{16}"
    },
    {
      "name": "MYSQL_DATABASE",
      "description": "Database name",
      "value": "sampledb"
    }
  ],
  "labels": {
    "template": "mysql-ephemeral-template"
  }
}
EOF

----

. Start the `database` service, using a slightly different method: the `oc process` command.
** Note that you are providing the `MYSQL_` values and processing the `mysql-template.json` file.
** You can save the `oc process` output into a file or "pipe" it into `oc create`.
+
----
[marina@master00~]$ oc process -f mysql-template.json \
  --value="MYSQL_USER=root,MYSQL_PASSWORD=redhat,MYSQL_DATABASE=mydb,DATABASE_SERVICE_NAME=database" | \
  tee mysql-processed.json
[marina@master00~]$ oc create -f  mysql-processed.json
----
+
** Alternatively, you can process the template, add your variables, and "pipe" the output directly to `oc create`.
** Note that here you are providing the `MYSQL_` attibutes and choosing the name of the service to be created.
+
----
[marina@master00~]$ oc process -f mysql-template.json --value="MYSQL_USER=root,MYSQL_PASSWORD=redhat,MYSQL_DATABASE=mydb,DATABASE_SERVICE_NAME=database" | oc create -f -
----

. Check that your values were processed correctly.
+
----
[marina@master00~]$ oc env dc/database --list
----
+
----
# deploymentconfigs mysql, container mysql
MYSQL_USER=root
MYSQL_PASSWORD=redhat
MYSQL_DATABASE=mydb
----

. Redeploy your front end so that it checks for the database again.
+
----
[marina@master00-GUID ~]$ oc deploy ruby-hello-world --latest
----

== Use Webhooks

Webhooks give you a way to integrate external systems into your OpenShift Enterprise environment so that these systems can start OpenShift Enterprise builds. Generally speaking, you would make code changes and update the code repository, and then some process would hit OpenShift Enterprise's webhook URL to start a build with the new code.

=== Create a Webhook

Your GitHub account has the capability to configure a webhook to request whenever you push a commit to a specific branch.

. To find the webhook URL:
.. Go to the web console.
.. Click into your project.
.. Click *Browse*, and then click *Builds*. 
* You will see two webhook URLs.

. Copy the *Generic* URL. 
* It should look like the following:
+
----
https://master00-GUID.oslab.opentlc.com:8443/osapi/v1/namespaces/lifecycle/buildconfigs/ruby-hello-world/webhooks/ALNUyArydLb22JqdXYIb/generic
----

. Get the `secret` password from the `BuildConfig`.
+
----
[marina@master00~]$ oc get bc ruby-hello-world -o yaml
----

. The output will look similar to the following. Use the `secret` value in your configuration in Git.
+
----
.... Cropped Output ....
  triggers:
  - github:
      secret: xTah2lioO2Bz9JZT9dPf
    type: GitHub
  - generic:
      secret: B5h3ARS88HD7S3LOcbRZ
    type: Generic
.... Cropped Output ....
----

. In the GitHub repository that you forked, go to *Settings -> Webhooks and Services*.

. Paste the URL you copied from the OpenShift Enterprise UI into the *Payload URL* field.

. Complete the `secret` field and disable SSL verification.

. Click *Add Webhook*.

=== Test Your Webhook

To test your webhook, you make a change to the code, commit, and then push the change into the Git repository.

[NOTE]
If you know how, you can do this the "normal" way by cloning your repository locally, making changes, and pushing them to the repository.

. GitHub's web interface lets you edit files. Go to your forked repository (eg: https://github.com/marina/ruby-hello-world), and find the file `main.erb` in the `views` folder.

. Change the following HTML:
+
----

    <div class="page-header" align=center>
      <h1> Welcome to an OpenShift v3 Demo App! </h1>
    </div>

----

* To read (include the typo):
+
----

    <div class="page-header" align=center>
      <h1> This is my crustom demo! </h1>
    </div>

----

. When you finish changing your code, commit the change to the repository.
. Check to see whether a build has been triggered.
+
[CAUTION]
If a build is currently running, your latest build might fail because both builds are pushing to the registry. Either stop the older build using `oc delete build`, or retry the failed build using `oc start-build`.

. Check the web interface (logged in as `marina`) to see that the build is running. 
. After the build has completed, point your web browser at the application: http://ruby-hello-world.lifecycle.cloudapps-GUID.oslab.opentlc.com/.

* You should see your output, including the typo.
+
[NOTE]
It can take a minute for your service endpoint to get updated. You might get a `503` error if you try to access the application before the update.


=== Roll Back Your Application

Because you failed to properly test your application, and your typo made it into production, you need to revert to the previous version of your application.

. Log in to the web console as `marina`.
. Find the *Deployments* section of the *Browse* menu. 
* You will see that there are two deployments of your front end: `1` and `2`.
+
[TIP]
====
You can also see this information from the CLI:

----

[marina@master00~]$ oc get replicationcontroller

----

The semantics of this syntax state that a `DeploymentConfig` ensures a `ReplicationController` is created to manage the deployment of the built `Image` from the `ImageStream`.
====

. Using the CLI, roll back a deployment.
.. Check which builds you have available.
+
----
[marina@master00~] oc get builds

----
.. Choose a deployment, and check what a rollback to `ruby-hello-world-X` would look like.
+
----

[marina@master00~]$ oc rollback ruby-hello-world-X --dry-run # X is your desired deployment
Name:           ruby-hello-world
Created:        39 minutes ago
Labels:         <none>
Latest Version: 9
Triggers:       Config, Image(ruby-hello-world@latest, auto=false)
Strategy:       Recreate
Template:
                        Selector:       deploymentconfig=ruby-hello-world
                        Replicas:       1
                        Containers:
                                NAME                    IMAGE                                                     ENV
                                ruby-hello-world        172.30.119.73:5000/lifecycle/ruby-hello-world@sha256:fcc9ce95e503429926dbe9e0cde304e0a0de19483e1cb79acada7334d7eb2504      MYSQL_DATABASE=mydb,MYSQL_PASSWORD=redhat,MYSQL_USER=root
Latest Deployment:      <none>

----

.. Because it looks fine, go ahead and roll back the deployment.
+
----

[marina@master00~]$ oc rollback ruby-hello-world-X # X is your desired deployment
#oc get9 rolled back to ruby-hello-world-X
Warning: the following images triggers were disabled: ruby-hello-world
  You can re-enable them with: oc deploy ruby-hello-world --enable-triggers

----

. Look at the *Browse* tab of your project, and observe that you have a new pod in the *Pods* section. 
. After a few minutes, go back to the application in your web browser, and you should see the old "Welcome..." text.

=== Roll Your Application Forward

. Roll forward (activate) the typo-enabled application:
+
----

[marina@master00~]$ oc rollback ruby-hello-world-X # X is your desired deployment
#11 rolled back to ruby-hello-world-X
Warning: the following images triggers were disabled: ruby-hello-world
  You can re-enable them with: oc deploy ruby-hello-world --enable-triggers

----

== Create Customized Build and Run Processes

OpenShift Enterprise 3 supports customization of both the build and run processes. Generally speaking, this involves modifying the various S2I scripts from the builder image. When OpenShift Enterprise builds your code, it checks to see if any of the scripts in the `.sti/bin` folder of your repository override or supercede the builder image's scripts. If so, it executes the repository script instead.

You can find more information on the scripts, their execution during the process, and customization at  https://docs.openshift.org/latest/creating_images/overview.html

=== Add a Script

. In a new tab in your web browser, open the following URL and copy all of the text:  http://www.opentlc.com/download/ose_implementation/resources/custom-assemble.sh

. Go to your GitHub repository for your application from the previous lab.

. In the GitHub web UI, navigate to the `.sti/bin` folder.

. Click the *+* button at the top (to the right of `bin` in the breadcrumbs).

. Name your file `assemble`.

. In the GitHub UI, paste the contents you copied earlier into the text area.

. Enter a commit message.

. Click *Commit*.
+
[NOTE]
If you know how to use GitHub, you can do this via your shell.

. After you add the file, you can do another build. 
* The custom assemble script logs some extra data.

=== Watch the Build Logs

. Using the skills you have learned, watch the build logs for this build. 

* If you miss the logs, remember that you can find the Docker container that ran the build and look at its Docker logs.
+
----

2015-03-11T14:57:00.022957957Z I0311 10:57:00.022913       1 sti.go:357]
---> CUSTOM S2I ASSEMBLE COMPLETE

----
+
NOTE: There is no output from the custom `run` script. The `assemble` script is run inside your builder pod. That is what you see by using `build-logs`: the output of the assemble script. The `run` script is what is actually executed to start your application's pod. In other words, the `run` script is what starts the Ruby process for an image that was built based on the `ruby-20-rhel7` S2I builder.

. To look inside the builder pod, as `marina`:
+
----

[marina@master00~]$ oc logs `oc get pod | grep -e "[0-9]-build" | tail -1 | awk {'print $1'}` | grep CUSTOM

----

* You should see something similar to the following:
+
----

2015-04-27T22:23:24.110630393Z ---> CUSTOM S2I ASSEMBLE COMPLETE

----
