== &nbsp;
:noaudio:

ifdef::revealjs_slideshow[]

[#cover,data-background-image="image/1156524-bg_redhat.png" data-background-color="#cc0000"]


[#cover-h1]
Red Hat OpenShift Enterprise Implementation

[#cover-h2]
Managing Security

[#cover-logo]
image::{revealjs_cover_image}[]

endif::[]
== Module Topics
:noaudio:

* Authentication
* Configuring Authentication
* Authorization
* Security Context Constraints (SCCs)
* Managing SCCs

ifdef::showscript[]

=== Transcript
Welcome to module nine of the OpenShift Enterprise Implementation course.

This module discusses the different authentication providers that  OpenShift Enterprise 3 supports. It shows how to configure `httpasswd` authentication and how the authorization mechanism operates.

This module also covers security context constraints, or SCCs, and how they effect capabilities of users and pods. It concludes with a review of common SCC management tasks.

endif::showscript[]


== Authentication
:noaudio:
.Overview
* Authentication layer:
** Identifies user associated with requests to OpenShift Enterprise API
** Uses information about user to determine whether to allow request

* Administrator can use master configuration file to configure authentication
* Learn more:
** Configuring authentication: https://docs.openshift.com/enterprise/3.0/admin_guide/configuring_authentication.html
** Master configuration file: https://docs.openshift.com/enterprise/3.0/admin_guide/master_node_configuration.html

* This section reviews:
** Users and groups
** API authentication
** OAuth

ifdef::showscript[]
=== Transcript
The authentication layer identifies the user associated with requests to the OpenShift Enterprise API. The authorization layer then uses information about the requesting user to determine whether to allow the request.

An administrator can use a master configuration file to configure authentication. Learn more at the links shown here.

This section reviews the following topics:

* Users and groups
* API authentication
* OAuth

endif::showscript[]

== Authentication
:noaudio:

.Users and Groups


* OpenShift Enterprise _user_:
** Can make requests to OpenShift Enterprise API
** Typically represents account of developer or administrator interacting with OpenShift Enterprise

* Can assign user to one or more _groups_
** Represent set of users
** Use to manage authorization policies to grant permissions to multiple users at once
** Example: Allow access to objects in project

* Learn more:
** Managing authorization policies: 
https://docs.openshift.com/enterprise/3.0/admin_guide/manage_authorization_policy.html
** Objects: https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/overview.html
** Projects: https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/projects_and_users.html#projects


ifdef::showscript[]
=== Transcript
A _user_ in OpenShift Enterprise is an entity that can make requests to the OpenShift Enterprise API. Typically, this represents a developer or administrator account that is interacting with OpenShift Enterprise.

You can assign a user to one or more _groups_. Each group represents a certain set of users.

Groups are useful when you are managing authorization policies to grant permissions to multiple users at once--for example, allowing access to objects within a project--versus granting permissions to users individually.

Learn more at the links shown here.

endif::showscript[]

== Authentication
:noaudio:

.Users and Groups

* Default virtual groups:

[cols="2,5"]
|===
|Virtual Group |Description
|`system:authenticated` |Automatically associated with currently authenticated users
|`system:unauthenticated` |Automatically associated with currently unauthenticated users
|===

* Support for developers and administrators to define custom groups under development
* Only currently existing groups are system groups, or _virtual groups_
** Automatically provisioned by OpenShift Enterprise
** Can view at https://docs.openshift.com/enterprise/3.0/admin_guide/manage_authorization_policy.html#viewing-cluster-bindings


ifdef::showscript[]
=== Transcript
In the default set of virtual groups, note the `system:authenticated` and `system:unauthenticated` groups in particular. These are automatically associated with currently authenticated and unauthenticated users, respectively.

Support for developers and administrators to define their own custom groups is currently under active development. At this time, the only groups that exist are system groups, or _virtual groups_, that are automatically provisioned by OpenShift Enterprise. You can view these at the web address shown here.


endif::showscript[]

== Authentication
:noaudio:

.API Authentication

* OpenShift Enterprise API requests authenticated using:

** OAuth access tokens:
*** Obtained from OpenShift Enterprise OAuth server using `_<master>_/oauth/authorize` and `_<master>_/oauth/token` endpoints
*** Sent as `Authorization: Bearer+++...+++` header or `access_token=+++...+++` query parameter

** X.509 client certificates:
*** Requires HTTPS connection to API server
*** Verified by API server against trusted certificate authority bundle
*** API server creates and distributes certificates to controllers to authenticate themselves

*** Authentication layer rejects request with invalid access token or certificate

ifdef::showscript[]
=== Transcript
Requests to the OpenShift Enterprise API are authenticated using Oauth access tokens and X.509 client certificates.

You obtain OAuth access tokens from the OpenShift Enterprise OAuth server using the endpoints shown here. You send them as either a header or a query parameter, as shown here.

X.509 client certificates require an HTTPS connection to the API server. The server verifies the certificates against a trusted certificate authority bundle, and then creates and distributes certificates to controllers to authenticate themselves.

The authentication layer rejects any request with an invalid access token or an invalid certificate with a 401 error.

endif::showscript[]

== Authentication
:noaudio:

.OAuth
* OpenShift Enterprise master includes built-in OAuth server
* Users obtain OAuth access tokens to authenticate to API

* When user requests OAuth token:
** OAuth server uses configured identity provider to determine identity of requester
** Learn more: https://docs.openshift.com/enterprise/3.0/admin_guide/configuring_authentication.html

* Server:
** Determines user to which identity maps
** Creates access token for user
** Returns token for use

* If no access token or certificate presented, authentication layer assigns
** `system:anonymous` virtual user
** `system:unauthenticated` virtual group
* Lets authorization layer determine requests anonymous user can make

ifdef::showscript[]
=== Transcript
The OpenShift Enterprise master includes a built-in OAuth server. Users obtain OAuth access tokens to authenticate themselves to the API.

When a user requests a new OAuth token, the OAuth server uses the configured identity provider to determine the identity of the person making the request.

Learn more at the link shown here.

It then determines what user that identity maps to, creates an access token for that user, and returns the token for use.

If no access token or certificate is presented, the authentication layer assigns the `system:anonymous` virtual user and the `system:unauthenticated` virtual group to the request. This allows the authorization layer to determine which requests, if any, an anonymous user can make.
endif::showscript[]

== Authentication
:noaudio:

.OAuth Clients

* OAuth token request must specify OAuth client that will receive and use token
* OAuth clients automatically created when starting OpenShift Enterprise API:

[cols="2,3"]
|===
|OAuth Client |Usage
|`openshift-web-console`
|Requests tokens for web console
|`openshift-browser-client`
|Requests tokens at `_<master>_/oauth/token/request` with user-agent that can handle interactive logins
|`openshift-challenging-client`
|Requests tokens with user-agent that can handle `WWW-Authenticate` challenges
|===

ifdef::showscript[]
=== Transcript
Every request for an OAuth token must specify the OAuth client that will receive and use the token.

The following OAuth clients are automatically created when starting the OpenShift Enterprise API:

* `openshift-web-console` requests tokens for the web console.
* `openshift-browser-client` requests tokens at `_<master>_/oauth/token/request` with user-agent that can handle interactive logins.
* `openshift-challenging-client` requests tokens with user-agent that can handle `WWW-Authenticate` challenges.

endif::showscript[]

== Configuring Authentication
:noaudio:

.Overview
* OpenShift Enterprise _master_ includes built-in OAuth server
* Developers/administrators obtain _OAuth access tokens_ to authenticate to API

* Administrator can configure OAuth using _master configuration file_ to specify _identity provider_

* _Deny All_ identity provider used by default
** Denies access for all usernames/passwords
** Must choose different identity provider and configure master configuration file to allow access
** Default master configuration file location: `/etc/origin/master/master-config.yaml`

* When running master without configuration file:
** _Allow All_ identity provider used by default
** Lets any non-empty username/password log in
** Useful for testing

ifdef::showscript[]
=== Transcript
The OpenShift Enterprise _master_ includes a built-in OAuth server. Developers and administrators obtain _OAuth access tokens_ to authenticate themselves to the API.

An administrator can configure OAuth using a _master configuration file_ to specify an _identity provider_.

The default identity provider is _Deny All_. This provider denies access for all user names and passwords. To allow access, you must choose a different identity provider and configure the master configuration file appropriately. By default, the master configuration file is located at  `/etc/origin/master/master-config.yaml.

When running a master without a configuration file, the identity provider defaults to _Allow All_. This allows any non-empty user name and password to log in. This is useful for testing purposes.

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers

* Can modify _master configuration file_ to configure master for authentication using desired identity provider

* Three parameters common to all identity providers:

[cols="2a,8a"]
|===
|Parameter     | Description
|`name`      | Provider name prefixed to provider usernames to form identity name
|`challenge` a|* When `true`, unauthenticated token requests from non-web
clients (i.e., CLI) sent `WWW-Authenticate` challenge header
* Not supported by all identity providers
* To prevent cross-site request forgery (CSRF) attacks against browser clients:
** Basic authentication challenges sent only if `X-CSRF-Token` header  present on request
** Clients expecting to receive basic `WWW-Authenticate` challenges should set header to non-empty value
|`login`     a|* When `true`, unauthenticated token requests from web clients (i.e., web console) redirected to login page backed by provider
* Not supported by all identity providers
|===

[[AllowAllPasswordIdentityProvider]]

ifdef::showscript[]
=== Transcript
To configure the master for authentication using your desired identity provider, you modify the _master configuration file_.

Three parameters are common to all identity providers: 

* `name` is the provider name prefixed to provider usernames to form the identity name.
* When `challenge` is `true`, unauthenticated token requests from non-web clients such as the CLI are sent the `WWW-Authenticate` challenge header. Some identity providers do not support the `challenge` parameter. To prevent cross-site request forgery (CSRF) attacks against browser clients, Basic authentication challenges are sent only if the `X-CSRF-Token` header is present on the request. Clients expecting to receive basic `WWW-Authenticate` challenges should set the header to a non-empty value.
* When `login` is `true`, unauthenticated token requests from web clients such as the web console are redirected to the login page backed by the provider. Some identity providers do not support the `login` parameter.

The next few slides review the different identity providers.

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers: Allow All

* Set `AllowAllPasswordIdentityProvider` in `identityProviders` stanza to allow any non-empty username/password to log in
* Default identity provider when running OpenShift Enterprise without _master configuration file_

* Master configuration using `AllowAllPasswordIdentityProvider`:
+
[source,yaml]
----
oauthConfig:
  ...
  identityProviders:
  - name: my_allow_provider <1>
    challenge: true <2>
    login: true <3>
    provider:
      apiVersion: v1
      kind: AllowAllPasswordIdentityProvider
----

ifdef::showscript[]
=== Transcript

You can set `AllowAllPasswordIdentityProvider` in the `identityProviders` stanza to allow any non-empty username/password to log in.

The _Allow All_ identity provider is the default identity provider when running
OpenShift Enterprise without a _master configuration file_.

The example here shows the master configuration using `AllowAllPasswordIdentityProvider`. Note the following:

. This provider name is prefixed to provider usernames to form an identity name.
. When `true`, unauthenticated token requests from non-web clients (like the CLI) are sent a `WWW-Authenticate` challenge header for this provider.
. When `true`, unauthenticated token requests from web clients (like the web console) are redirected to a login page backed by this provider.


endif::showscript[]


== Configuring Authentication
:noaudio:

.Identity Providers: Deny All

* Set `DenyAllPasswordIdentityProvider` in `identityProviders` stanza to deny access for all usernames/passwords
* Default identity provider when running OpenShift Enterprise with _master configuration file_

* Master configuration using `DenyAllPasswordIdentityProvider`:
+
[source,yaml]
----
oauthConfig:
  ...
  identityProviders:
  - name: my_deny_provider <1>
    challenge: true <2>
    login: true <3>
    provider:
      apiVersion: v1
      kind: DenyAllPasswordIdentityProvider
----

ifdef::showscript[]
=== Transcript

You can set `DenyAllPasswordIdentityProvider` in the `identityProviders` stanza to deny access for all usernames and passwords.

The _Deny All_ identity provider is the default identity provider when running OpenShift Enterprise with a _master configuration file_.

The example here shows the master configuration using `DenyAllPasswordIdentityProvider`. Note the following:

. This provider name is prefixed to provider usernames to form an identity name.
. When `true`, unauthenticated token requests from non-web clients (like the CLI) are sent a `WWW-Authenticate` challenge header for this provider.
. When `true`, unauthenticated token requests from web clients (like the web console) are redirected to a login page backed by this provider.


endif::showscript[]

== Configuring Authentication
:noaudio:

//ISSUE: Bob - This could benefit from expand/collapse I think

.Identity Providers: LDAP Authentication

* Set `LDAPPasswordIdentityProvider` in `identityProviders` stanza to validate usernames and passwords against LDAPv3 server
** Uses simple bind authentication

* During authentication:
** LDAP directory searched for entry matching provided username
** If single unique match found, simple bind attempted using entry distinguished name (DN) plus password

* Authentication steps:

. To generate search filter, combine attribute and filter in configured `url` with user-provided username
. Search directory using filter
** If search does not return exactly one entry, deny access
. Attempt to bind to LDAP server using DN of entry retrieved from search and user-provided password
** If bind unsuccessful, deny access
** If bind successful, build identity using configured attributes as:
*** Identity
*** Email address
*** Display name
*** Preferred username


ifdef::showscript[]
=== Transcript

You can set `LDAPPasswordIdentityProvider` in the `identityProviders` stanza to validate usernames and passwords against an LDAPv3 server, using simple bind authentication.

During authentication, the LDAP directory is searched for an entry that matches the provided username. If search finds a single unique match, it attempts a simple bind using the distinguished name (DN) of the entry plus the provided password.

The authentication steps are as follows:

. Generate a search filter by combining the attribute and filter in the configured `url` with the user-provided username.
. Search the directory using the generated filter. If the search does not return exactly one entry, deny access.
. Attempt to bind to the LDAP server using the DN of the entry retrieved from the search and the user-provided password.
** If the bind is unsuccessful, deny access.
** If the bind is successful, build an identity using the configured attributes as the identity, email address, display name, and preferred username.

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers: `htpasswd`

* Set `HTPasswdPasswordIdentityProvider` in `identityProviders` stanza to validate usernames and passwords against flat file generated using `htpasswd`
** Learn more: http://httpd.apache.org/docs/2.4/programs/htpasswd.html

* Supports MD5 and SHA encryption types only
** MD5 encryption recommended, default for `htpasswd`
** Not supported: Plaintext, crypt, bcrypt hashes

* Flat file reread if modification time changes
** Server restart not required

ifdef::showscript[]
=== Transcript

You can set `HTPasswdPasswordIdentityProvider` in the `identityProviders` stanza to validate usernames and passwords against a flat file generated using `htpasswd`. For more information, see the link shown here.

Currently, OpenShift Enterprise supports MD5 and SHA encryption types only. MD5 encryption, which is the default for `htpasswd`, is recommended.

Plaintext, crypt, or bcrypt hashes currently are not supported.

The flat file is reread if its modification time changes, without requiring a server restart.

endif::showscript[]

== Configuring Authentication
:noaudio:

* Master configuration using `HTPasswdPasswordIdentityProvider`:
+
[source,yaml]
----
oauthConfig:

  identityProviders:
  - name: my_htpasswd_provider <1>
    challenge: true <2>
    login: true <3>
    provider:
      apiVersion: v1
      kind: HTPasswdPasswordIdentityProvider
      file: /path/to/users.htpasswd <4>
----


ifdef::showscript[]
=== Transcript
Here is an example of the `oauthConfig` section of the master configuration file that defines the use of `HTPasswdPasswordIdentityProvider` with the file `/path/to/users.htpasswd`.

Note the following:

. This provider name is prefixed to provider usernames to form an identity name.
. When `true`, unauthenticated token requests from non-web clients (like the CLI) are sent a `WWW-Authenticate` challenge header for this provider.
. When `true`, unauthenticated token requests from web clients (like the web console) are redirected to a login page backed by this provider.
. This is the file generated using `htpasswd`.

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers: `htpasswd` Commands

* To create file:
+
----
$ htpasswd -c </path/to/users.htpasswd> <user_name>
----

* To add or update login to file:
+
----
$ htpasswd </path/to/users.htpasswd> <user_name>
----

* To remove login from file:
+
----
$ htpasswd </path/to/users.htpasswd> -D <user_name>
----



ifdef::showscript[]
=== Transcript
You can use the commands shown here to create the password file and create or remove user logins.

endif::showscript[]



== Authorization
:noaudio:

.Overview
* Authorization policies: Determine whether user may perform _action_ within project
* Lets platform administrators use _cluster policy_
** Control access levels to OpenShift Enterprise platform and projects
* Lets developers use _local policy_
** Control access to own projects

* Authorization separate from _authentication_, which determines identity of person taking action

ifdef::showscript[]
=== Transcript
Authorization policies determine whether a user may perform a given _action_ within a project. This lets platform administrators use the _cluster policy_ to control who has various access levels to the OpenShift Enterprise platform itself and all projects. It also lets developers use _local policy_ to control who has access to the developers' own projects.

Authorization is a separate step from _authentication_, which is more about determining the identity of the person taking the action.

endif::showscript[]

== Authorization
:noaudio:

.Managing Authorization

* Manage authorization using:

[.noredheader, cols="1,7"]
|===
|*Rules* a|* Sets of permitted _verbs_ on a set of _objects_
*  Example: Whether something can `create` [verb] `pods` [object]
|*Roles* a|* Collections of rules
* _Users and groups_ can be associated with, or _bound_ to, multiple _roles_ at same time
|*Bindings* |Associations between users/groups with _role_
|===

ifdef::showscript[]
=== Transcript
You manage authorization using rules, roles, and bindings.

*Rules* are sets of permitted verbs on a set of objects--for example, whether something can create [verb] pods [object].
*Roles* are collections of *rules*. Users and groups can be associated with, or bound to, multiple roles at the same time.
*Bindings* are associations between users and/or groups with a role.

endif::showscript[]

== Authorization
:noaudio:

.Visualizing Rules, Roles, and Bindings

//ISSUE: Bob - This could benefit from expand/collapse I think

* Can use CLI to visualize rules, roles, bindings
* Example: Show rule sets for `admin` and `basic-user`
** Uses `oc describe clusterPolicy default`:
+
[options="nowrap"]
----
admin			Verbs					Resources															Resource Names	Extension
			[create delete get list update watch]	[projects resourcegroup:exposedkube resourcegroup:exposedopenshift resourcegroup:granter secrets]				[]
			[get list watch]			[resourcegroup:allkube resourcegroup:allkube-status resourcegroup:allopenshift-status resourcegroup:policy]			[]
basic-user		Verbs					Resources															Resource Names	Extension
			[get]					[users]																[~]
			[list]					[projectrequests]														[]
			[list]					[projects]															[]
			[create]				[subjectaccessreviews]														[]		IsPersonalSubjectAccessReview
----



* Example: View policy bindings
** Shows above roles bound to various users/groups
** Uses `oc describe clusterPolicy default`:
+
[options="nowrap"]
----
RoleBinding[admins]:
				Role:	admin
				Users:	[alice system:admin]
				Groups:	[]
RoleBinding[basic-user]:
				Role:	basic-user
				Users:	[joe]
				Groups:	[devel]
----


ifdef::showscript[]
=== Transcript
You can use the CLI to visualize rules, roles, and bindings. The first sample here shows rule sets for the `admin` and `basic-user`, using the command `oc describe clusterPolicy default`.

The second sample views policy bindings and shows the above roles bound to various users and groups, using the command: `oc describe clusterPolicy default`.
endif::showscript[]

== Authorization
:noaudio:

.Evaluating Authorization

* Factors combined to make decision when evaluating authorization:

[.noredheader, cols="1,7"]
|===
|*Identity* |In authorization context, both username and list of groups to which user belongs
|*Action* a|Action being performed; usually consists of:
[horizontal]
Project:: Project being accessed
Verb:: Can be `get`, `list`, `create`, `update`, other
Resource Name:: API endpoint being accessed
|*Bindings* |Full list of bindings: https://docs.openshift.com/enterprise/3.0/architecture/additional_concepts/authorization.html#bindings
|===

ifdef::showscript[]
=== Transcript

OpenShift Enterprise combines several factors to make the decision when evaluating authorization. These include identity, action, and bindings.

endif::showscript[]


== Authorization
:noaudio:

.Evaluating Authorization: Workflow

* Steps OpenShift Enterprise uses to evaluate authorization:

. Use identity and project-scoped action to find all bindings applicable to user/groups
. Use bindings to locate applicable roles
. Use roles to find applicable rules
. Check action against each rule to find match
** If no matching rule found, action denied by default

ifdef::showscript[]
=== Transcript
* OpenShift Enterprise evaluates authorization using the following steps:

. OpenShift Enterprise uses the identity and the project-scoped action to find all bindings that apply to the user or the user's groups.
. It then uses bindings to locate all the roles that apply.
. Next it uses roles to find all the rules that apply.
. Finally, it checks the action against each rule to find a match.
** If it does not find a matching rule, the action is denied by default.

endif::showscript[]


== Authorization
:noaudio:

//ISSUE: Bob - This could benefit from expand/collapse I think

.Cluster Policy and Local Policy

* Two levels of authorization policies:

[cols="2"]
|===
|Cluster Policy  |Local Policy
a|* Roles and bindings applicable across all projects
* _Cluster roles_: Roles existing in cluster policy
* Cluster bindings can reference cluster roles only
a|* Roles and bindings scoped to given project
* _Local roles_: Roles existing in local policy only
* Local bindings can reference cluster and local roles
|===

* Two-level hierarchy allows: 
** Reusability over multiple projects through cluster policy
** Customization inside individual projects through local policies

* Both cluster and local bindings used during evaluation
* Example:
** Cluster-wide `allow` rules checked
** Locally bound `allow` rules checked
** Deny by default


ifdef::showscript[]
=== Transcript

There are two levels of authorization policies: _cluster policy_ and _local policy_.

Cluster policy includes roles and bindings that are applicable across all projects. Roles that exist in the cluster policy are considered cluster roles. Cluster bindings can reference cluster roles only.

Local policy includes roles and bindings that are scoped to a given project. Roles that exist only in a local policy are considered local roles. Local bindings can reference both cluster and local roles.

This two-level hierarchy allows reusability over multiple projects through the cluster policy while allowing customization inside individual projects through local policies.

During evaluation, both the cluster bindings and the local bindings are used. For example:

First, the cluster-wide `allow` rules are checked. Then the locally-bound `allow` rules are checked. Authorization denies by default.
endif::showscript[]

== Authorization
:noaudio:

.Roles
* *Roles*: Collections of policy _rules_
** Verbs permitted to perform on set of resources
* OpenShift Enterprise includes default roles
** Can add to users/groups in _cluster policy_ or _local policy_

* Can use CLI to visualize roles in cluster policy
** Includes matrix of verbs and resources associated with role
** Lists  additional _system_ roles
*** Used for OpenShift Enterprise operations

* Default: In local policy, only _admin_ role binding listed when using CLI to view local bindings
** Can add default roles to users/groups within local policy
** These appear in CLI output

ifdef::showscript[]
=== Transcript

Roles are collections of policy _rules_, which are sets of permitted verbs that you can perform on a set of resources.
OpenShift Enterprise includes a set of default roles that you can add to users and groups in either the _cluster policy_ or the  _local policy_.

You can use the CLI to visualize these roles, including a matrix of the verbs and resources associated with each role, in the cluster policy. The CLI output lists additional _system_ roles as well. OpenShift Enterprise uses these roles for various system and component operations.

By default, in a local policy, only the binding for the _admin_ role is immediately listed when you use the CLI to view local bindings. However, if you add other default roles to users and groups within a local policy, these become listed in the CLI output as well.


endif::showscript[]

== Authorization
:noaudio:

.Roles: Default Roles
* OpenShift Enterprise includes default roles
* Can add to users/groups in _cluster policy_ or _local policy_

[cols="1,4"]
|===
|Default Role |Description
|`admin` a|* Project manager
* If used in _local binding_, has rights to view any resource in project and modify any resource in project 
* Exceptions: Role creation and quota
|`basic-user` |User that can get basic information about projects and users
|`cluster-admin` a|* Super-user that can perform any action in any project
* When granted to user within local policy, user has full control over quota and roles and every action on every resource in project
|`cluster-status` |User that can get basic cluster status information
|`edit` a|* User that can modify most objects in project
* Does not have power to view or modify roles or bindings
|`self-provisioner` a|* User that can create own projects
* Default for all users
|`view` a|* User who cannot make any modifications
* Can see most objects in project
* Cannot view or modify roles or bindings
|===

* Can associate users and groups with, or bind them to, multiple roles at same time.
** Learn more: https://docs.openshift.com/enterprise/3.0/architecture/additional_concepts/authentication.html#users-and-groups

ifdef::showscript[]
=== Transcript
OpenShift Enterprise includes a set of default roles that you can add to users and groups in either the _cluster policy_ or the _local policy_.

The `admin` user is a project manager. If used in a _local binding_, an `admin` user has rights to view any resource in the project and modify
any resource in the project except for role creation and quota.

The `basic-user` is a user that can get basic information about projects they participate in and the projects' users.

The `cluster-admin` is a super-user that can perform any action in any project. When granted to a user within a local policy, this user has full control over quota and roles and every action on every resource in the project.

The `cluster-status` role lets a user get basic cluster status information.

The `edit` role lets a user modify most objects in a project, but does not give the user the power to view or modify roles or bindings.

The `self-provisioner` is a user that can create his or her own projects, All users are granted this role by default.

The `view` role prohibits a user from making any modifications but lets the user see most objects in a project. These users cannot view or modify roles or bindings.

You can associate users and groups with, or bind them to, multiple roles at same time.

endif::showscript[]

== Authorization
:noaudio:

.Roles: Creating Roles

* If default roles unsuitable, `cluster-admin` can:
** Create `policyBinding` object named `_<projectname>_:default`
** With CLI using JSON file
* Lets project `admin` bind users to roles  defined in `_<projectname>_` local policy

* Default role may be updated after product update
* To check if update recommended for your environment, run `oadm policy reconcile-cluster-roles`
** Outputs list of out-of-date roles and new values
* Can either:
** Modify and apply output yourself
** Run `oadm policy reconcile-cluster-roles --confirm` and automatically apply changes

ifdef::showscript[]
=== Transcript
If you find that the default roles do not suit you, a `cluster-admin` user can create a `policyBinding` object named `_<projectname>_:default` with the CLI using a JSON file. This lets the project `admin` bind users to roles that are defined in the `_<projectname>_` local policy only.

After a product update, the recommended default roles may be updated.  To check if an update is recommended for your environment, you can run `oadm policy reconcile-cluster-roles`. This command outputs a list of roles that are out-of-date, along with their new values. You can either modify and apply this output yourself, or run `oadm policy reconcile-cluster-roles --confirm` and automatically apply the changes.

endif::showscript[]

== Security Context Constraints (SCCs)
:noaudio:

.Overview

* _Authorization policies_ control what user can do
* In addition, _security context constraints_ (SCCs) control:
** Actions that pod can perform
** What pod can access

* *SCCs*: Define conditions pod must run with to be accepted into system
* Let administrator control:

** Running privileged containers
** Capabilities container can request to be added
** Use of host directories as volumes
** SELinux context of container
** User ID within container

ifdef::showscript[]
=== Transcript
In addition to _authorization policies_ that control what a user can do, OpenShift Enterprise provides _security context constraints_, or SCCs, that control the actions that a pod can perform and what it can access.

SCCs are objects that define a set of conditions that a pod must run with to be accepted into the system. SCCs let an administrator control the
following:

* Running of privileged containers
* Capabilities a container can request to be added
* Use of host directories as volumes
* SELinux context of the container
* User ID within the container
endif::showscript[]

== Security Context Constraints (SCCs)
:noaudio:

.Privileged and Restricted SCCs

* Two SCCs added to cluster by default: _privileged_ and _restricted_
* Cluster administrator can use CLI to view:
+
----
$ oc get scc
NAME         PRIV      CAPS      HOSTDIR   SELINUX     RUNASUSER
privileged   true      []        true      RunAsAny    RunAsAny
restricted   false     []        false     MustRunAs   MustRunAsRange

----

* The privileged SCC:
** Allows privileged pods
** Lets host directories be mounted as volumes
** Lets pod run as any user
** Lets pod run with any MCS label

* The restricted SCC:
** Ensures pods cannot run as privileged
** Ensures pods cannot use host directory volumes
** Requires pod to run as user in preallocated range of UIDs
** Requires pod to run with preallocated MCS label


ifdef::showscript[]
=== Transcript
Two SCCs are added to the cluster by default: _privileged_ and _restricted_.

Cluster administrators can view the SCCs using the CLI.

The privileged SCC allows privileged pods, allows host directories to be mounted as volumes, and allows a pod to run as any user and with any MCS label.


The restricted SCC ensures pods cannot run as privileged or host directory volumes, and requires that a pod runs as a user in a preallocated range of UIDs and with a pre-allocated MCS label.

endif::showscript[]

== Security Context Constraints (SCCs)
:noaudio:

.Privileged and Restricted SCCs: Definition

* _Users_ and _groups_ fields on SCC define users and groups subject to SCC
** Default: Cluster administrators, nodes, and build controller granted access to privileged SCC
** All authenticated users granted access to restricted SCC

* Cluster administrators can use CLI to view SCC definition
* Example: For privileged SCC:
+
----
# oc export scc/privileged
allowHostDirVolumePlugin: true
allowPrivilegedContainer: true
apiVersion: v1
groups: <1>
- system:cluster-admins
- system:nodes
kind: SecurityContextConstraints
metadata:
  creationTimestamp: null
  name: privileged
runAsUser:
  type: RunAsAny <2>
seLinuxContext:
  type: RunAsAny <3>
users: <4>
- system:serviceaccount:openshift-infra:build-controller
----

ifdef::showscript[]
=== Transcript

The _users_ and _groups_ fields on the SCC define the users and groups that are subject to the SCC.
By default, cluster administrators, nodes, and the build controller are granted access to the privileged SCC.
All authenticated users are granted access to the restricted SCC.

Cluster administrators can use the CLI to view the definition for each SCC. The example here shows output for the privileged SCC. Note the following:

. These are the groups that have access to this SCC.
. This is the run as user strategy type, which dictates the allowable values for the Security Context.
. This is thee SELinux context strategy type, which dictates the allowable values for the Security Context.
. These are the users who have access to this SCC.

endif::showscript[]

== Security Context Constraints (SCCs)
:noaudio:

.Privileged and Restricted SCCs: Settings

* SCCs comprised of settings and strategies
* Control security features pod can access
* Settings fall into three categories:

[.noredheader, cols="1,4"]
|===
|*Controlled by a boolean*
 a|* Fields of this type default to most restrictive value
* Example: `AllowPrivilegedContainer` always set to `false` if unspecified
|*Controlled by an allowable set*
|Fields of this type checked against set to ensure value is allowed
|*Controlled by a strategy*
a|* Items that have strategy to generate value provide:
** Mechanism to generate value
** Mechanism to ensure specified value falls into set of allowable values
|===

ifdef::showscript[]
=== Transcript
SCCs are comprised of settings and strategies that control the security features a pod can access. These settings fall into three categories: *Controlled by a boolean*, *Controlled by an allowable set*, and *Controlled by a strategy*.
endif::showscript[]

== Security Context Constraints (SCCs)
:noaudio:

.Admission

* Use _admission control_ to control resource/action creation
** Based on capabilities granted to user/pod

* Authorizes pod to:
** Make requests about operating environment
** Generate constraints to apply to pod

* SCCs that _admission_ uses to authorize pod determined by:
** User identity
** Groups to which user belongs
* If pod specifies service account:
** Allowable SCCs includes constraints accessible to service account

ifdef::showscript[]
=== Transcript

You use _admission control_ to have control over the creation of resources and actions based on the capabilities granted to a user or a pod.

Doing so authorizes the pod to make requests about its operating environment or to generate a set of constraints to apply to the pod.

The set of SCCs that _admission_ uses to authorize a pod are determined by the user identity and groups to which the user belongs. Additionally, if the pod specifies a service account, the set of allowable SCCs includes any constraints accessible to the service account.
endif::showscript[]

== Security Context Constraints (SCCs)
:noaudio:

.Admission: Approach

* Admission's approach to creating final security context for pod:
** Retrieve SCCs available for use
** Generate field values for any security context setting not specified on request
** Validate final settings against available constraints

* If matching set of constraints found, pod is accepted
* If request cannot be matched to SCC, pod is rejected

ifdef::showscript[]
=== Transcript
* _Admission_ uses the following approach to create the final security context for the pod:
First, retrieve all SCCs available for use.
Next, generate field values for any security context setting that was not specified on the request.
Finally, validate the final settings against the available constraints.

If a matching set of constraints is found, then the pod is accepted. If the request cannot be matched to an SCC, the pod is rejected.

endif::showscript[]

== Managing SCCs
:noaudio:

.Overview

* Can manage SCCs in instance as normal API _objects_ using CLI
* Must have `cluster-admin` privileges

ifdef::showscript[]
=== Transcript
You can manage SCCs in your instance as normal API _objects_ using the CLI. To manage SCCs, you must be a `cluster-admin`.
endif::showscript[]

== Managing SCCs
:noaudio:

.Listing SCCs

* To get current list of SCCs:
+
----
$ oc get scc
NAME         PRIV      CAPS      HOSTDIR   SELINUX     RUNASUSER
privileged   true      []        true      RunAsAny    RunAsAny
restricted   false     []        false     MustRunAs   MustRunAsRange
----

ifdef::showscript[]
=== Transcript
To get a current list of SCCs, use the `oc get scc` command.
endif::showscript[]

== Managing SCCs
:noaudio:

.Creating SCCs: Part 1

* To create SCC, first define SCC in JSON or YAML file
* SCC object definition:
+
----
kind: SecurityContextConstraints
apiVersion: v1
metadata:
  name: scc-admin
allowPrivilegedContainer: true
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: RunAsAny
users:
- my-admin-user
----

ifdef::showscript[]
=== Transcript
To create a new SCC, you first define the SCC in a JSON or YAML file similar to the example shown here.
endif::showscript[]

== Managing SCCs
:noaudio:

.Creating SCCs: Part 2

* Run `oc create` passing file:
+
----
$ oc create -f scc_admin.yaml
securitycontextconstraints/scc-admin

$ oc get scc
NAME         PRIV      CAPS      HOSTDIR   SELINUX     RUNASUSER
privileged   true      []        true      RunAsAny    RunAsAny
restricted   false     []        false     MustRunAs   MustRunAsRange
scc-admin    true      []        false     RunAsAny    RunAsAny
----

ifdef::showscript[]
=== Transcript
Next, you run the `oc create` command, passing the file to create it. To see your new SCC, use the `oc get scc` command.
endif::showscript[]

== Managing SCCs
:noaudio:

.Deleting and Updating SCCs

* To delete CC:
+
----
$ oc delete scc <scc_name>
----

* If you delete default SCCs:
** Not regenerated on restart unless you delete all SCCs
* No regeneration if any constraint in system

.Updating SCCs

* To update existing SCC:
+
----
$ oc edit scc <scc_name>
----

ifdef::showscript[]
=== Transcript
To delete an SCC, use the `oc delete` command as shown here.

If you delete the default SCCs, they are not regenerated on restart unless you delete all SCCs. If there are any constraints within the system, no regeneration takes place.

To update an existing SCC, use the `oc edit` command as shown here.
endif::showscript[]

== Managing SCCs
:noaudio:

.Granting Access to the Privileged SCC

* Administrator might want to create privileged pods
** Provide access to users/groups outside administrator group
** To do so, use `oc edit` to add user/group to `users` or `groups` field of SCC
** Example: To allow `e2e-user` access to `privileged` SCC, add username to `users` list:
+
[source,yaml]
----
$ oc edit scc privileged

allowHostDirVolumePlugin: true
allowPrivilegedContainer: true
apiVersion: v1
groups:
- system:cluster-admins
- system:nodes
kind: SecurityContextConstraints
metadata:
  creationTimestamp: 2015-06-15T20:44:53Z
  name: privileged
  resourceVersion: "58"
  selfLink: /api/v1/securitycontextconstraints/privileged
  uid: 602a0838-139f-11e5-8aa4-080027c5bfa9
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: RunAsAny
users:
- system:serviceaccount:openshift-infra:build-controller
- e2e-user <1>

----


ifdef::showscript[]
=== Transcript
In some cases, an administrator might want to provide access to users or groups outside the administrator group to create more privileged pods.

To do so, you use the `oc edit` command to add the user or group to the `users` or `groups` field of the SCC.
In the example shown here, you add `e2e-user` to the `user` list of the privileged SCC to allow `e2e-user` to create privileged pods.

Note the following:

. This shows `e2e-user` added to the users section.

endif::showscript[]

== Managing SCCs
:noaudio:

.Enabling Images to Run With `USER` in the Dockerfile

* Can relax security in cluster so that:
** Images not forced to run as preallocated UID
** Without granting everyone access to privileged SCC

. Edit restricted SCC:
+
----
$ oc edit scc restricted
----

. Change `runAsUser.Type` strategy to `RunAsAny`

** Lets images run as root UID if no `USER` specified in Dockerfile


ifdef::showscript[]
=== Transcript

You can relax the security in your cluster so that images are not forced to run as a preallocated UID, without granting everyone access to the privileged SCC.

To do this, edit the restricted SCC and change the `RunAsUser` type to `RunAsAny`.

This also lets images run as the root UID if no `USER` is specified in the Dockerfile.

endif::showscript[]

== Managing SCCs
:noaudio:

.Using the `hostPath` Volume Plug-in

* Can relax security in cluster so that:
** Pods can use `hostPath` volume plug-in
** Without granting everyone access to privileged SCC

. Edit restricted SCC:
+
----
$ oc edit scc restricted
----

. Add `allowHostDirVolumePlugin: true`

. Save changes

ifdef::showscript[]
=== Transcript
You can relax the security in your cluster so that pods can use the `hostPath` volume plug-in without granting everyone access to the privileged SCC.

To do this, edit the restricted SCC and add the `allowHostDirVolumePlugin: true` flag.

endif::showscript[]

== Summary
:noaudio:

* Authentication
* Configuring Authentication
* Authorization
* Security Context Constraints
* Managing SCCs

ifdef::showscript[]
=== Transcript
This module described the different authentication providers that OpenShift Enterprise 3 supports. It showed how to configure `htpasswd` authentication and how the authorization mechanism operates.

It also covered SCCs and how they effect capabilities of users and pods, and reviewed common SCC management tasks.
endif::showscript[]
