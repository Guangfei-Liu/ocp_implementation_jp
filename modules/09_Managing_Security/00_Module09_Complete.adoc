== &nbsp;
:noaudio:

ifdef::revealjs_slideshow[]

[#cover,data-background-image="image/1156524-bg_redhat.png" data-background-color="#cc0000"]


[#cover-h1]
Red Hat OpenShift Enterprise Implementation

[#cover-h2]
OpenShift 3.0 Installation

[#cover-logo]
image::{revealjs_cover_image}[]

endif::[]
== Module Topics
:noaudio:

* Authentication
* Configuring Authentication
* Authorization
* Security Context Constraints
* Managing Security Context Constraints
* Summary
* Lab : Managing Authentication
* Lab : Manage Security Constraints


ifdef::showscript[]

=== Transcript
Welcome to Module 06 of the OpenShift Enterprise Implementation course.
endif::showscript[]


== Authentication
:noaudio:
.Overview
* The authentication layer identifies the user associated with requests to the
OpenShift API. The authorization layer then uses information about the
requesting user to determine if the request should be allowed.

* As an administrator, you can
link:https://docs.openshift.com/enterprise/3.0/admin_guide/configuring_authentication.html[configure authentication]
using a link:https://docs.openshift.com/enterprise/3.0/admin_guide/master_node_configuration.html[master
configuration file].

* In this section we will review:
** Users and Groups
** API Authentication
** OAuth

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authentication
:noaudio:

.Users and Groups


* A _user_ in OpenShift is an entity that can make requests to the OpenShift API.
Typically, this represents the account of a developer or administrator that is
interacting with OpenShift.

* A user can be assigned to one or more _groups_, each of which represent a
certain set of users.
* Groups are useful when
link:https://docs.openshift.com/enterprise/3.0/admin_guide/manage_authorization_policy.html[managing authorization
policies] to grant permissions to multiple users at once, for example allowing
access to link:https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/overview.html[objects] within a
link:https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/projects_and_users.html#projects[project], versus granting
them to users individually.

NOTE: Support for developers and administrators to define their own custom groups is
currently under active development. At this time, the only groups that exist are
system groups, or _virtual groups_, that are automatically provisioned by
OpenShift. These can be seen when
link:https://docs.openshift.com/enterprise/3.0/admin_guide/manage_authorization_policy.html#viewing-cluster-bindings[viewing
cluster bindings].

In the default set of virtual groups, note the following in
particular:

[cols="2,5",options="header"]
|===

|Virtual Group |Description

|*system:authenticated* |Automatically associated with any currently-authenticated users.
|*system:unauthenticated* |Automatically associated with any currently-unauthenticated users.

|===

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authentication
:noaudio:

.API Authentication

* Requests to the OpenShift API are authenticated using the following methods:

** OAuth Access Tokens:
- Obtained from the OpenShift OAuth server using the `_<master>_/oauth/authorize` and `_<master>_/oauth/token` endpoints.
- Sent as an `Authorization: Bearer+++...+++` header or an `access_token=+++...+++` query parameter

** X.509 Client Certificates:
*** Requires a HTTPS connection to the API server.
*** Verified by the API server against a trusted certificate authority bundle.
*** The API server creates and distributes certificates to controllers to authenticate themselves.

NOTE: Any request with an invalid access token or an invalid certificate is rejected
by the authentication layer with a 401 error.

NOTE: If no access token or certificate is presented, the authentication layer assigns
the `system:anonymous` virtual user and the `system:unauthenticated` virtual
group to the request. This allows the authorization layer to determine which
requests, if any, an anonymous user is allowed to make.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authentication
:noaudio:

.OAuth
* The OpenShift master includes a built-in OAuth server. Users obtain OAuth
access tokens to authenticate themselves to the API.

* When a person requests a new OAuth token, the OAuth server uses the configured
link:https://docs.openshift.com/enterprise/3.0/admin_guide/configuring_authentication.html[identity
provider] to determine the identity of the person making the request.

** It then determines what user that identity maps to, creates an access token for
that user, and returns the token for use.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authentication
:noaudio:

.OAuth Clients

* Every request for an OAuth token must specify the OAuth client that will
receive and use the token.
* The following OAuth clients are automatically created
when starting the OpenShift API:
+
[options="header"]
|===

|OAuth Client |Usage

|*openshift-web-console*
|Requests tokens for the web console.

|*openshift-browser-client*
|Requests tokens at `_<master>_/oauth/token/request` with a user-agent that can handle interactive logins.

|*openshift-challenging-client*
|Requests tokens with a user-agent that can handle `WWW-Authenticate` challenges.

|===

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Overview
* The OpenShift _master_ includes a built-in OAuth Server.
* Developers and administrators obtain _OAuth access tokens_ to authenticate
themselves to the API.

* As an administrator, you can configure _OAuth_ using a
_master configuration file_ to specify an _identity provider_.

* The _Deny All_ identity provider is used by default, which denies access for
all user names and passwords. To allow access, you must choose a different
identity provider and configure the master
configuration file appropriately (located at
*_/etc/openshift/master/master-config.yaml_* by default).

* When running a master without a configuration file, the _Allow All_ identity
provider is used by default, which allows any non-empty user name and password to log in. This is
useful for testing purposes.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers

* You can configure the master for authentication using your desired identity
provider by modifying the _master configuration file_. The following sections
detail the identity providers
supported by OpenShift.

* There are three parameters common to all identity providers:
+
[cols="2a,8a",options="header"]
|===
|Parameter     | Description
.^|`name`      | The provider name is prefixed to provider user names to form an
identity name.
.^|`challenge` | When *true*, unauthenticated token requests from non-web
clients (like the CLI) are sent a `WWW-Authenticate` challenge header. Not
supported by all identity providers.

To prevent cross-site request forgery (CSRF) attacks against browser clients
Basic authentication challenges are only sent if a `X-CSRF-Token` header is
present on the request. Clients that expect to receive Basic `WWW-Authenticate`
challenges should set this header to a non-empty value.

.^|`login`     | When *true*, unauthenticated token requests from web clients
(like the web console) are redirected to a login page backed by this provider.
Not supported by all identity providers.
|===

[[AllowAllPasswordIdentityProvider]]

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers - Allow All

* Set _AllowAllPasswordIdentityProvider_ in the `*identityProviders*` stanza to
allow any non-empty user name and password to log in. This is the default
identity provider when running OpenShift without a _master configuration file_.

* Master Configuration Using *AllowAllPasswordIdentityProvider*:
+
[source,yaml]
----
oauthConfig:
  ...
  identityProviders:
  - name: my_allow_provider <1>
    challenge: true <2>
    login: true <3>
    provider:
      apiVersion: v1
      kind: AllowAllPasswordIdentityProvider
----
<1> This provider name is prefixed to provider user names to form an identity
name.
<2> When *true*, unauthenticated token requests from non-web clients (like
the CLI) are sent a `WWW-Authenticate` challenge header for this provider.
<3> When *true*, unauthenticated token requests from web clients (like the web
console) are redirected to a login page backed by this provider.


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers - Deny All

* Set _DenyAllPasswordIdentityProvider_ in the `identityProviders` stanza to
deny access for all user names and passwords.

* Master Configuration Using *DenyAllPasswordIdentityProvider*:
+
[source,yaml]
----
oauthConfig:
  ...
  identityProviders:
  - name: my_deny_provider <1>
    challenge: true <2>
    login: true <3>
    provider:
      apiVersion: v1
      kind: DenyAllPasswordIdentityProvider
----
<1> This provider name is prefixed to provider user names to form an identity
name.
<2> When *true*, unauthenticated token requests from non-web clients (like the
CLI) are sent a `WWW-Authenticate` challenge header for this provider.
<3> When *true*, unauthenticated token requests from web clients (like the web
console) are redirected to a login page backed by this provider.


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers - HTPasswd

* Set _HTPasswdPasswordIdentityProvider_ in the `identityProviders` stanza to
validate user names and passwords against a flat file generated using
http://httpd.apache.org/docs/2.4/programs/htpasswd.html[`htpasswd`].

* Only MD5 and SHA encryption types are supported. MD5 encryption is recommended,
and is the default for `htpasswd`.
** Plaintext, crypt, and bcrypt hashes are not currently supported.

* The flat file is re-read if its modification time changes, without requiring a
server restart.

* Master Configuration Using *HTPasswdPasswordIdentityProvider*:
+
[source,yaml]
----
oauthConfig:

  identityProviders:
  - name: my_htpasswd_provider <1>
    challenge: true <2>
    login: true <3>
    provider:
      apiVersion: v1
      kind: HTPasswdPasswordIdentityProvider
      file: /path/to/users.htpasswd <4>
----

<1> This provider name is prefixed to provider user names to form an identity
name.
<2> When *true*, unauthenticated token requests from non-web clients (like the
CLI) are sent a `WWW-Authenticate` challenge header for this provider.
<3> When *true*, unauthenticated token requests from web clients (like the web
console) are redirected to a login page backed by this provider.
<4> File generated using
http://httpd.apache.org/docs/2.4/programs/htpasswd.html[`htpasswd`].

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers - HTPasswd Continued

* To create the file, run:
+
----
$ htpasswd -c </path/to/users.htpasswd> <user_name>
----

* To add or update a login to the file, run:
+
----
$ htpasswd </path/to/users.htpasswd> <user_name>
----

* To remove a login from the file, run:
+
----
$ htpasswd </path/to/users.htpasswd> -D <user_name>
----



ifdef::showscript[]
=== Transcript

endif::showscript[]

== Configuring Authentication
:noaudio:

.Identity Providers - LDAP Authentication

* Set _LDAPPasswordIdentityProvider_ in the `identityProviders` stanza to
validate user names and passwords against an LDAPv3 server, using simple bind
authentication.

* During authentication, the LDAP directory is searched for an entry that matches
the provided user name. If a single unique match is found, a simple bind is
attempted using the distinguished name (DN) of the entry plus the provided
password.
* Here are the steps taken:

. Generate a search filter by combining the attribute and filter in the
configured `*url*` with the user-provided user name.
. Search the directory using the generated filter. If the search does not return
exactly one entry, deny access.
. Attempt to bind to the LDAP server using the DN of the entry retrieved from
the search, and the user-provided password.
. If the bind is unsuccessful, deny access.
. If the bind is successful, build an identity using the configured attributes
as the identity, email address, display name, and preferred user name.




ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Overview
* Authorization policies determine whether a user is allowed to perform a given
_action_ within a project.
* This allows platform administrators to use the _cluster policy_ to control
who has various access levels to the OpenShift platform itself and all projects.
* It also allows developers to use _local policy_ to control who has access to
their _projects_.

NOTE: Authorization is a separate step from _authentication_, which is more
about determining the identity of who is taking the action.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Overview - Continued

* Authorization is managed using:

[cols="1,7"]
|===

|*Rules* |Sets of permitted _verbs_ on a set of _objects_.
For example, whether something can
`create` [verb] `pods` [object].
|*Roles* |Collections of rules. _Users and groups_ can be associated
with, or _bound_ to, multiple _roles_ at the same time.
|*Bindings* |Associations between users and/or groups with a _role_
|===

* Rules, roles, and bindings can be visualized using the CLI. For example,
consider the following excerpt showing rule sets for the *admin* and
*basic-user* (Using the command `oc describe clusterPolicy default`):
+
[options="nowrap"]
----
admin			Verbs					Resources															Resource Names	Extension
			[create delete get list update watch]	[projects resourcegroup:exposedkube resourcegroup:exposedopenshift resourcegroup:granter secrets]				[]
			[get list watch]			[resourcegroup:allkube resourcegroup:allkube-status resourcegroup:allopenshift-status resourcegroup:policy]			[]
basic-user		Verbs					Resources															Resource Names	Extension
			[get]					[users]																[~]
			[list]					[projectrequests]														[]
			[list]					[projects]															[]
			[create]				[subjectaccessreviews]														[]		IsPersonalSubjectAccessReview
----


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Overview - Continued
* The following excerpt of viewing policy bindings shows the above roles
bound to various users and groups (Using the command: `oc describe clusterPolicy default`):
+
[options="nowrap"]
----
RoleBinding[admins]:
				Role:	admin
				Users:	[alice system:admin]
				Groups:	[]
RoleBinding[basic-user]:
				Role:	basic-user
				Users:	[joe]
				Groups:	[devel]
----


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Evaluating Authorization

* Several factors are combined to make the decision when OpenShift evaluates
authorization:

[cols="1,7"]
|===

|*Identity* |In the context of authorization, both the user name and
list of groups the user belongs to.

|*Action* a|The action being performed. In most cases, this consists of:

[horizontal]
Project:: The _project_ being accessed.
Verb:: Can be `get`, `list`, `create`, `update`, or others.
Resource Name:: The API endpoint being accessed.

|*Bindings* |The full list of link:https://docs.openshift.com/enterprise/3.0/architecture/additional_concepts/authorization.html#bindings[bindings].

|===

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Evaluating Authorization - Continued

* OpenShift evaluates authorizations using the following steps:

. The identity and the project-scoped action is used to find all bindings that
apply to the user or their groups.
. Bindings are used to locate all the roles that apply.
. Roles are used to find all the rules that apply.
. The action is checked against each rule to find a match.
. If no matching rule is found, the action is then denied by default.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Cluster Policy and Local Policy

* There are two levels of authorization policy:

[cols="1,4"]
|===

|*Cluster policy* |_Roles_ and bindings that are applicable across
all projects. Roles that exist in the cluster policy are considered _cluster
roles_. `Cluster bindings can only reference cluster roles`.

|*Local policy* |_Roles_ and bindings that are scoped to a given
project. Roles that exist only in a local policy are considered _local roles_.
`Local bindings can reference both cluster and local roles`.

|===

* This two-level hierarchy allows re-usability over multiple projects through the
cluster policy while allowing customization inside of individual projects
through local policies.

* During evaluation, both the cluster bindings and the local bindings are used.
For example:

. Cluster-wide "allow" rules are checked.
. Locally-bound "allow" rules are checked.
. Deny by default.


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Roles
* Roles are collections of policy _rules_, which are sets of
permitted verbs that can be performed on a set of resources.
* OpenShift includes a set of default roles that can be added to users and
groups in the _cluster policy_ or the  _local policy_. (Detailed in the next
  slide)

* These roles, including a matrix of the verbs and resources each are associated
  with, can be visualized in the cluster policy by using the CLI. Additional
  _system_ roles are listed as well, which are used for various OpenShift
  system and component operations.

* By default in a local policy, only the binding for the _admin_ role is
  immediately listed when using the CLI to _view local bindings_. However, if other default roles are added to users and groups
  within a local policy, they become listed in the CLI output, as well.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Roles - Continued
* OpenShift includes a set of default roles that can be added to users and
groups in the _cluster policy_ or the  _local policy_.
[cols="1,4",options="header"]
|===

|Default Role |Description

|*admin* |A project manager. If used in a _local binding_, an *admin* user will
have rights to view any resource in the project and modify any resource in the
project except for role creation and quota. If the *cluster-admin* wants to
allow an *admin* to modify roles, the *cluster-admin* must create a
project-scoped _Policy_ object using JSON. (We will cover this later)

|*basic-user* |A user that can get basic information about projects and users.

|*cluster-admin* |A super-user that can perform any action in any project. When
granted to a user within a local policy, they have full control over quota and
roles and every action on every resource in the project.

|*cluster-status* |A user that can get basic cluster status information.

|*edit* |A user that can modify most objects in a project, but does not have the
power to view or modify roles or bindings.

|*self-provisioner* |A user that can create their own projects.

|*view* |A user who cannot make any modifications, but can see most objects in a
project. They cannot view or modify roles or bindings.

|===

TIP: Remember that link:https://docs.openshift.com/enterprise/3.0/architecture/additional_concepts/authentication.html#users-and-groups[users
and groups] can be associated with, or _bound_ to, multiple roles at the same
time.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Authorization
:noaudio:

.Roles - Continued

* If you find that these roles do not suit you, a *cluster-admin* user can create
a `policyBinding` object named `_<projectname>_:default` with the CLI using a
JSON file.
** This allows the project *admin* to bind users to roles that are
defined only in the `_<projectname>_` local policy.


NOTE: After a product update, the recommended default roles may be updated.  To check
if an update is recommended for your environment, you can run `oadm policy reconcile-cluster-roles`.
This command will output a list of roles that are out of date and their new values.
You may either take this output, modify, and apply it yourself or you may run
`oadm policy reconcile-cluster-roles --confirm` and automatically apply the changes.



ifdef::showscript[]
=== Transcript

endif::showscript[]

== Security Context Constraints
:noaudio:

.Overview

* In addition to _authorization policies_ that control what a user
can do, OpenShift provides _security context constraints_ (SCC) that control the
actions that a _pod_ can perform and what it has the ability to access.

* SCCs are objects that define a set of conditions that a pod must run with in
order to be accepted into the system. They allow an administrator to control the
following:

. Running of privileged containers.
. Capabilities a container can request to be added.
. Use of host directories as volumes.
. The SELinux context of the container.
. The user ID. (within the container)

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Security Context Constraints
:noaudio:

.Overview - Continued

* Two SCCs are added to the cluster by default, _privileged_ and _restricted_,
which are viewable by cluster administrators using the CLI:
+
----
$ oc get scc
NAME         PRIV      CAPS      HOSTDIR   SELINUX     RUNASUSER
privileged   true      []        true      RunAsAny    RunAsAny
restricted   false     []        false     MustRunAs   MustRunAsRange
----

* The definition for each SCC is also viewable by cluster administrators using the
CLI. For example, for the privileged SCC:
+
----
# oc export scc/privileged
allowHostDirVolumePlugin: true
allowPrivilegedContainer: true
apiVersion: v1
groups: <1>
- system:cluster-admins
- system:nodes
kind: SecurityContextConstraints
metadata:
  creationTimestamp: null
  name: privileged
runAsUser:
  type: RunAsAny <2>
seLinuxContext:
  type: RunAsAny <3>
users: <4>
- system:serviceaccount:openshift-infra:build-controller
----

<1> The groups that have access to this SCC
<2> The run as user strategy type which dictates the allowable values for the Security Context
<3> The SELinux context strategy type which dictates the allowable values for the Security Context
<4> The users who have access to this SCC

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Security Context Constraints
:noaudio:

.Privileged and Restricted SCCs

* The _users_ and _groups_ fields on the SCC control which SCCs can be used.
By default, cluster administrators, nodes, and the build controller are granted
access to the privileged SCC.
* All authenticated users are granted access to the restricted SCC.

* The privileged SCC:
** allows privileged pods.
**  allows host directories to be mounted as volumes.
**  allows a pod to run as any user.
**  allows a pod to run with any MCS label.

* The restricted SCC:
** ensures pods cannot run as privileged.
** ensures pods cannot use host directory volumes.
** requires that a pod run as a user in a pre-allocated range of UIDs.
** requires that a pod run with a pre-allocated MCS label.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Security Context Constraints
:noaudio:

.Privileged and Restricted SCCs - Continued

* SCCs are comprised of settings and strategies that control the security features
a pod has access to. These settings fall into three categories:

[cols="1,4"]
|===

|*Controlled by a boolean*
|Fields of this type default to the most restrictive value. For example,
`AllowPrivilegedContainer` is always set to *false* if unspecified.

|*Controlled by an allowable set*
|Fields of this type are checked against the set to ensure their value is
allowed.

|*Controlled by a strategy*
a|Items that have a strategy to generate a value provide:

* A mechanism to generate the value, and
* A mechanism to ensure that a specified value falls into the set of allowable
values.

|===

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Security Context Constraints
:noaudio:

.Admission

* _Admission control_ with SCCs allows for control over the creation of resources
based on the capabilities granted to a user.

* In terms of the SCCs, this means that an admission controller can inspect the
user information made available in the context to retrieve an appropriate set of
SCCs.
** Doing so ensures the pod is authorized to make requests about its operating
environment or to generate a set of constraints to apply to the pod.

* The set of SCCs that admission uses to authorize a pod are determined by the
user identity and groups that the user belongs to.
** Additionally, if the pod specifies a service account, the set of allowable
SCCs includes any constraints accessible to the service account.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Security Context Constraints
:noaudio:

.Admission - Continued
* Admission uses the following approach to create the final security context for
the pod:

. Retrieve all SCCs available for use.
. Generate field values for any security context setting that was not specified
on the request.
. Validate the final settings against the available constraints.

If a matching set of constraints is found, then the pod is accepted. If the
request cannot be matched to an SCC, the pod is rejected.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Overview
You can manage _security context constraints_ (SCCs) in your instance as normal
API _objects_ using the CLI.

NOTE: You must have _cluster-admin_ privileges to manage SCCs.



ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Listing Security Context Constraints

* To get a current list of SCCs:
+
----
$ oc get scc
NAME         PRIV      CAPS      HOSTDIR   SELINUX     RUNASUSER
privileged   true      []        true      RunAsAny    RunAsAny
restricted   false     []        false     MustRunAs   MustRunAsRange
----

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Creating New Security Context Constraints

* To create a new SCC, first define the SCC in a JSON or YAML file:
* Security Context Constraint Object Definition:
+
----
kind: SecurityContextConstraints
apiVersion: v1
metadata:
  name: scc-admin
allowPrivilegedContainer: true
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: RunAsAny
users:
- my-admin-user
groups:
- my-admin-group
----

* Then, run `oc create` passing the file to create it:
+
----
$ oc create -f scc_admin.yaml
securitycontextconstraints/scc-admin

$ oc get scc
NAME         PRIV      CAPS      HOSTDIR   SELINUX     RUNASUSER
privileged   true      []        true      RunAsAny    RunAsAny
restricted   false     []        false     MustRunAs   MustRunAsRange
scc-admin    true      []        false     RunAsAny    RunAsAny
----

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Deleting Security Context Constraints

* To delete an SCC:
+
----
$ oc delete scc <scc_name>
----

NOTE: If you delete the default SCCs, they will not be regenerated upon restart,
unless you delete all SCCs. If any constraint already exists within the system,
no regeneration will take place.

.Updating Security Context Constraints

* To update an existing SCC:
+
----
$ oc edit scc <scc_name>
----

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Grant Access to the Privileged SCC

* In some cases, an administrator might want to allow users or groups outside
the administrator group access to create more privileged pods. To do so, you can:

. Determine the user or group you would like to have access to the SCC.
+
----
$ oc edit scc <name>
----

. Add the user or group to the *users* or *groups* field of the SCC.
.. For example, to allow the *e2e-user* access to the *privileged* SCC, add
their user:
+
[source,yaml]
----
$ oc edit scc privileged

allowHostDirVolumePlugin: true
allowPrivilegedContainer: true
apiVersion: v1
groups:
- system:cluster-admins
- system:nodes
kind: SecurityContextConstraints
metadata:
  creationTimestamp: 2015-06-15T20:44:53Z
  name: privileged
  resourceVersion: "58"
  selfLink: /api/v1/securitycontextconstraints/privileged
  uid: 602a0838-139f-11e5-8aa4-080027c5bfa9
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: RunAsAny
users:
- system:serviceaccount:openshift-infra:build-controller
- e2e-user <1>

----

<1> The *e2e-user* added to the users section.


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Enable Images to Run with USER in the Dockerfile

* To relax the security in your cluster so that images are not forced to run as
a pre-allocated UID, without granting everyone access to the *privileged* SCC:

. Edit the *restricted* SCC:
+
----
$ oc edit scc restricted
----

. Change the `*runAsUser.Type*` strategy to *RunAsAny*.

IMPORTANT: This allows images to run as the root UID if no _USER_ is specified
in the _Dockerfile_.


ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Modify Cluster Default Behavior

* To modify your cluster so that it does not pre-allocate UIDs, allows containers
to run as any user, and prevents privileged containers:

. Edit the *restricted* SCC:
+
----
 $ oc edit scc restricted
----

. Change `*runAsUser.Type*` to *RunAsAny*.

. Ensure `*allowPrivilegedContainer*` is set to false.

. Save the changes.

* To modify your cluster so that it does not pre-allocate UIDs and does not allow
containers to run as root:

. Edit the *restricted* SCC:
+
----
 $ oc edit scc restricted
----

. Change `*runAsUser.Type*` to *MustRunAsNonRoot*.

. Save the changes.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Managing Security Context Constraints
:noaudio:

.Use the hostPath Volume Plug-in

To relax the security in your cluster so that pods are allowed to use the `hostPath`
volume plug-in without granting everyone access to the *privileged* SCC:

. Edit the *restricted* SCC:
+
----
$ oc edit scc restricted
----

. Add `*allowHostDirVolumePlugin: true*`.

. Save the changes.

ifdef::showscript[]
=== Transcript

endif::showscript[]

== Summary
:noaudio:

* Authentication
* Configuring Authentication
* Authorization
* Security Context Constraints
* Managing Security Context Constraints
* Summary
* Lab : Managing Authentication
* Lab : Manage Security Constraints





ifdef::showscript[]
=== Transcript

endif::showscript[]
