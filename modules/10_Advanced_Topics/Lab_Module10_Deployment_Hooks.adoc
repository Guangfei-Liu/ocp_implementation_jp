== Lab: Lifecycle Pre and Post Deployment Hooks

Like in OpenShift 2, we have the capability of "hooks" - performing actions both
before and after the **deployment**. In other words, once an S2I build is
complete, the resulting Docker image is pushed into the registry. Once the push
is complete, OpenShift detects an `ImageChange` and, if so configured, triggers
a **deployment**.

The *pre*-deployment hook is executed just *before* the new image is deployed.

The *post*-deployment hook is executed just *after* the new image is deployed.

How is this accomplished? OpenShift will actually spin-up an *extra* instance of
your built image, execute your hook script(s), and then shut the instance down.
Neat, huh?

=== Create your application

NOTE: Remember that a `BuildConfig`(uration) tells OpenShift how to do a build.

. As *root*, Create a project for Marina to work with:
+
----
[root@master00 ~]# oadm new-project lifecyclehooks --display-name="Lifecycle Hooks Lab" \
    --description="This is the project we use to learn about Lifecycle Hooks" \
    --admin=marina --node-selector='region=primary'
----

. Switch to Marina and use the *"lifecyclehooks"* project.
+
----
[root@master00 ~]# su - marina
[marina@master00 ~]$ oc login -u marina --insecure-skip-tls-verify --server=https://master00-${guid}.oslab.opentlc.com:8443
[marina@master00 ~]$ oc project lifecyclehooks
----

. Lets create an app based on your fork of the ruby-hello-world
+
----
[marina@master00~]$ oc new-app https://github.com/sborenst/ruby-hello-world --strategy=source
----
+
NOTE: Notice that we are using `"--strategy=source"` to force the *oc new-app*
command to use the S2I strategy.

let's go ahead and add a database migration file.  Open a web browser to the following URL:
+
----
https://raw.githubusercontent.com/openshift/training/master/beta4/1_sample_table.rb
----

. In your forked repository of `ruby-hello-world` create a file called `db/migrate/1_sample_table.rb` with the content from the file in the last step.

=== Examining Deployment Hooks

Take a look at the following JSON:

    "strategy": {
        "type": "Recreate",
        "resource": {},
        "recreateParams": {
            "pre": {
                "failurePolicy": "Abort",
                "execNewPod": {
                    "command": [
                        "/bin/true"
                    ],
                    "env": [
                        {
                            "name": "CUSTOM_VAR1",
                            "value": "custom_value1"
                        }
                    ],
                    "containerName": "ruby-helloworld"
                }
            },
            "post": {
                "failurePolicy": "Ignore",
                "execNewPod": {
                    "command": [
                        "/bin/false"
                    ],
                    "env": [
                        {
                            "name": "CUSTOM_VAR2",
                            "value": "custom_value2"
                        }
                    ],
                    "containerName": "ruby-helloworld"
                }
            }
        }
    },

You can see that both a *pre* and *post* deployment hook are defined. They don't
actually do anything useful. But they are good examples.

The pre-deployment hook executes "/bin/true" whose exit code is always 0 --
success. If for some reason this failed (non-zero exit), our policy would be to
`Abort` -- consider the entire deployment a failure and stop.

The post-deployment hook executes "/bin/false" whose exit code is always 1 --
failure. The policy is to `Ignore`, or do nothing. For non-essential tasks that
might rely on an external service, this might be a good policy.

More information on these strategies, the various policies, and other
information can be found in the documentation:

    http://docs.openshift.org/latest/dev_guide/deployments.html



=== Modifying the Hooks

. Before we continue, Use what you have learned to deploy the database for our
application:
+
----
[marina@master00-a167 ~]$ oc create -f mysql-processed.json
----

. Since we are talking about **deployments**, let's look at our
`DeploymentConfig`s. As the `marina` user.
+
----

[marina@master00~]$ oc get dc

----
+
You should see something like (Version number are likely to be different):
+
----

NAME               TRIGGERS                    LATEST VERSION
database           Change, ConfigChange        1
ruby-hello-world   ConfigChange, ImageChange   1


----

. Since we are trying to associate a Rails database migration hook with our
application, we are ultimately talking about a deployment of the frontend (ruby-hello-world). If
you edit the ruby-hello-world's `DeploymentConfig` as `marina`:
+
----

[marina@master00~]$ oc edit dc ruby-hello-world -o json

----

. Yes, the default for `oc edit` is to use YAML. For this exercise, JSON will be
easier as it is indentation-insensitive. Find the section that looks like the
following before continuing:
+
----

    "spec": {
        "strategy": {
            "type": "Recreate",
            "resources": {}
        },

----

A Rails migration is commonly performed when we have added/modified the database
as part of our code change. In the case of a pre- or post-deployment hook, it
would make sense to:

* Attempt to migrate the database

* Abort the new deployment if the migration fails

Otherwise we could end up with our new code deployed but our database schema
would not match. This could be a *Real Bad Thing*.

In the case of the `ruby-20` builder image, we are actually using RHEL7 and the
Red Hat Software Collections (SCL) to get our Ruby 2.0 support. So, the command
we want to run looks like:

    /usr/bin/scl enable ruby200 ror40 'cd /opt/openshift/src ; bundle exec rake db:migrate'

This command:

* executes inside an SCL "shell"

* enables the Ruby 2.0.0 and Ruby On Rails 4.0 environments

* changes to the `/opt/openshift/src` directory (where our applications' code is
    located)

* executes `bundle exec rake db:migrate`

If you're not familiar with Ruby, Rails, or Bundler, that's OK.

The `command` directive inside the hook's definition tells us which command to
actually execute. It is required that this is an array of individual strings.
Represented in JSON, our desired command above represented as a string array
looks like:

    "command": [
        "/usr/bin/scl",
        "enable",
        "ruby200",
        "ror40",
        "cd /opt/openshift/src ; bundle exec rake db:migrate"
    ]

This is great, but actually manipulating the database requires that we talk
**to** the database. Talking to the database requires a user and a password.
Smartly, our hook pods inherit the same environment variables as the main
deployed pods, so we'll have access to the same datbase information.

Looking at the original hook example in the previous section, and our command
reference above, in the end, you will have something that looks like:
+
[source,json]
----
    "strategy": {
        "type": "Recreate",
        "resources": {},
        "recreateParams": {
            "pre": {
                "failurePolicy": "Abort",
                "execNewPod": {
                    "command": [
                        "/usr/bin/scl",
                        "enable",
                        "ruby200",
                        "ror40",
                        "cd /opt/openshift/src ; bundle exec rake db:migrate"
                    ],
                    "containerName": "ruby-hello-world"
                }
            },
        }
    },
----

Remember, indentation isn't critical in JSON, but closing brackets and braces
are. When you are done editing the deployment config, save and quit your editor.

=== Build Again

Now that we have modified the deployment configuration and cleaned up a bit, we
need to trigger another deployment. While killing the frontend pod would trigger
another deployment, our current Docker image doesn't have the database migration
file in it. Nothing really useful would happen.

In order to get the database migration file into the Docker image, we actually
need to do another build. Remember, the S2I process starts with the builder
image, fetches the source code, executes the (customized) assemble script, and
then pushes the resulting Docker image into the registry. **Then** the
deployment happens.

. As `marina`:
+
----

[marina@master00~]$ oc start-build ruby-hello-world

----
+
Or go into the web console and click the "Start Build" button in the Builds
area.

=== Verify the Migration

. About a minute after the build completes, you should see something like the following output
of `oc get pod` as `marina`:
+
----

[marina@master00~]$ oc get pod

----
+
----

POD                                IP          CONTAINER(S)               IMAGE(S)                                                                                                                HOST                                    LABELS                                                                                                                  STATUS       CREATED         MESSAGE
database-2-rj72q                   10.1.0.15                                                                                                                                                      master00-GUID.oslab.opentlc.com/192.168.133.2   deployment=database-2,deploymentconfig=database,name=database                                                           Running      About an hour
                                               ruby-helloworld-database   registry.access.redhat.com/openshift3_beta/mysql-55-rhel7                                                                                                                                                                                                                               Running      About an hour
deployment-frontend-7-hook-4i8ch                                                                                                                                                                  node00-GUID.oslab.opentlc.com/192.168.133.3    <none>                                                                                                                  Succeeded    41 seconds
                                               lifecycle                  172.30.118.110:5000/wiring/origin-ruby-sample@sha256:2984cfcae1dd42c257bd2f79284293df8992726ae24b43470e6ffd08affc3dfd                                                                                                                                                                   Terminated   36 seconds      exit code 0
frontend-7-nnnxz                   10.1.1.24                                                                                                                                                      node00-GUID.oslab.opentlc.com/192.168.133.3    deployment=frontend-7,deploymentconfig=frontend,name=frontend                                                           Running      29 seconds
                                               ruby-helloworld            172.30.118.110:5000/wiring/origin-ruby-sample@sha256:2984cfcae1dd42c257bd2f79284293df8992726ae24b43470e6ffd08affc3dfd                                                                                                                                                                   Running      26 seconds
ruby-sample-build-7-build                                                                                                                                                                         master00-GUID.oslab.opentlc.com/192.168.133.2   build=ruby-sample-build-7,buildconfig=ruby-sample-build,name=ruby-sample-build,template=application-template-stibuild   Succeeded    2 minutes
                                               sti-build                  openshift3_beta/ose-sti-builder:v0.5.2.2                                                                                                                                                                                                                                                Terminated   2 minutes       exit code 0

----
+
You'll see that there is a single `hook`/`lifecycle` pod -- this corresponds
with the pod that ran our pre-deployment hook.

. Inspect this pod's logs:
+
----

[marina@master00~]$ oc logs deployment-frontend-7-hook-4i8ch

----
+
The output should show something like:
+
----

== 1 SampleTable: migrating ===================================================
-- create_table(:sample_table)
   -> 0.1075s
== 1 SampleTable: migrated (0.1078s) ==========================================

----
+
If you have no output, you may have forgotten to actually put the migration file
in your repo. Without that file, the migration does nothing, which produces no
output.
+
You can even talk directly to the database on its service IP/port
using the `mysql` client and the environment variables (you would need the
`mysql` package installed on your master, for example).

. As `marina`, find your database:
+
----

[marina@master00~]$ oc get service
NAME       LABELS    SELECTOR        IP(S)            PORT(S)
database   <none>    name=database   172.30.108.133   5434/TCP
frontend   <none>    name=frontend   172.30.229.16    5432/TCP

----
+
Take note of the database IP and PORT.

. Get database connection info:
+
----

[marina@master00~]$ oc get dc database -o yaml | grep -A1 MYSQL

----
+
----

  - name: MYSQL_USER
    value: [username]
  - named: MYSQL_PASSWORD
    value: [password]
  - name: MYSQL_DATABASE
    value: [database]

----

. As root on the master host install the mysql client:
+
----

[root@master00~]# yum -y install mariadb

----

. Then use the `mysql` client to connect to this service using the connection information discovered in the earlier steps and dump the table that we created:
+
----

[marina@master00~]$ mysql -u[username] \
      -p[password] \
      -h[db_IP] \
      -P[db_PORT] \
      -e'show tables; describe sample_table;' \
      [database]

----
+
----

+-------------------+
| Tables_in_root    |
+-------------------+
| sample_table      |
| key_pairs         |
| schema_migrations |
+-------------------+
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | NO   |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+

----
